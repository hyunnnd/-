

## **Link layer: introduction**

**용어 정리:**
- **hosts와 routers:** 노드(nodes)
- **통신 경로를 따라 인접 노드를 연결하는 통신 채널:** 링크(links)
    - 유선(wired)
    - 무선(wireless)
    - LANs
- **2계층 패킷:** 프레임(frame)
    - 프레임은 데이터그램을 포함(encapsulate)함

**링크 계층(link layer)**은  
한 노드에서 **물리적으로 인접한** 다른 노드로  
데이터그램을 전송하는 책임을 가짐.

# 🔵 **간단 요약**

링크 계층은 **같은 링크 상에 물리적으로 연결된 노드들 간** 데이터그램을 프레임 형태로 전달하는 역할을 담당함.



### **Link layer: context**

- 데이터그램은 여러 링크에서 **다른 링크 프로토콜**에 의해 전송됨
    - 예: 첫 번째 링크는 WiFi, 다음 링크는 Ethernet
- 각 링크 프로토콜은 **서로 다른 서비스**를 제공함
    - 예: 신뢰적인 데이터 전송을 제공할 수도 있고, 제공하지 않을 수도 있음

### **운송(transportation) 비유:**

- Princeton → Lausanne 여행
    - 리무진: Princeton → JFK
    - 비행기: JFK → Geneva
    - 기차: Geneva → Lausanne
- **관광객 = 데이터그램**
- **각 이동 구간 = 통신 링크**
- **이동 수단 = 링크 계층 프로토콜**
- **여행사 = 라우팅 알고리즘**

# 🔵 **간단 요약**

데이터그램은 목적지까지 가는 동안 여러 종류의 링크(WiFi, Ethernet 등)를 거치며, 각 링크는 서로 다른 프로토콜과 기능을 제공함. 이를 여행에 비유하여, 관광객은 데이터그램, 이동 구간은 링크, 이동 수단은 링크 프로토콜, 여행사는 라우팅 알고리즘으로 설명함.


## **링크 계층: 서비스**

- **프레이밍(frming), 링크 접근(link access):**
    - 데이터그램을 프레임에 캡슐화하여 헤더와 트레일러를 추가함
    - 공유 매체인 경우 채널 접근 필요
    - 프레임 헤더의 **MAC 주소**는 출발지와 목적지를 식별함  
        (IP 주소와는 다른 주소임!)


- **인접 노드 간의 신뢰성 있는 전달(reliable delivery):**    
    - 우리는 이미 이 방법을 알고 있음
    - 오류율이 낮은 링크에서는 거의 사용되지 않음
    - 무선 링크는 오류율이 높음
    - **Q:** 왜 링크 계층과 종단 간(end-to-end) 모두에서 신뢰성 기능이 필요한가?


# 🔵 **간단 요약**

링크 계층은 데이터그램을 프레임으로 감싸고, MAC 주소를 기반으로 이웃 노드와 통신함. 무선처럼 오류율이 높은 구간에서는 링크 계층에서 신뢰성 있는 전달(재전송 등)이 필요하지만, 전체 경로에 대한 신뢰성은 전송 계층(TCP)이 담당하기 때문에 두 계층에서 각각 신뢰 메커니즘이 존재함.


## **링크 계층: 서비스 (추가)**

- **흐름 제어(flow control):**
    - 인접한 송신 노드와 수신 노드 사이의 전송 속도 조절

- **오류 검출(error detection):**    
    - 신호 감쇠, 잡음 등에 의해 발생하는 오류를 탐지
    - 수신자가 오류를 감지하면 재전송을 요청하거나 프레임을 폐기함

- **오류 정정(error correction):**    
    - 수신자가 비트 오류를 **재전송 없이** 스스로 식별하고 수정할 수 있음

- **반이중(half-duplex)과 전이중(full-duplex):**
  
    - 반이중: 링크 양쪽 노드가 전송할 수는 있지만 **동시에**는 불가능     
    - 전이중: 양쪽이 동시에 송수신 가능

# 🔵 **간단 요약**

링크 계층은 인접 노드 간 통신 품질을 보장하기 위해 흐름 제어, 오류 검출 및 정정 기능을 제공하며, 무선 등 다양한 매체에서 반이중 또는 전이중 방식으로 동작할 수 있다.


## Multiple access links, protocols

두 가지 종류의 “링크”:

### **point-to-point(점대점)**

- 이더넷 스위치와 호스트 간의 점대점 링크
- 전화 접속(dial-up)을 위한 PPP

### **broadcast (공유된 전선 또는 매체)**

- 오래된 형태의 이더넷
- 케이블 기반 액세스 네트워크의 업스트림 HFC
- 802.11 무선 LAN, 4G/5G, 위성 통신

(아래 그림: 공유된 유선(Ethernet), 공유 무선(4G/5G, WiFi), 위성, 사람들이 하나의 공기를 공유하며 대화하는 상황 등)

# 🔵 **간단 요약**

네트워크 링크는 **점대점 링크**(1:1 연결)와 **브로드캐스트 링크**(여러 노드가 하나의 매체를 공유)로 나눌 수 있다. 브로드캐스트 방식은 WiFi, 4G/5G, 이더넷 허브, 위성 등의 공유 매체 기반 네트워크에서 사용된다.


## Multiple access protocols

- 단일 공유 브로드캐스트 채널
- 노드들이 동시에 두 개 이상 전송하면 간섭 발생
    - 하나의 노드가 두 개 이상의 신호를 동시에 받으면 _collision(충돌)_ 발생

### **multiple access protocol (다중 접근 프로토콜)**

- 노드들이 채널을 어떻게 공유할지 결정하는 **분산 알고리즘**  
    즉, 어떤 노드가 언제 전송할 수 있는지를 결정함    
- 채널 공유에 대한 통신도 **해당 채널 자체를 사용해야 함**
    - 조정을 위한 별도의(out-of-band) 채널이 없음

# 🔵 **간단 요약**

여러 노드가 하나의 공유 채널을 사용할 때 동시에 전송하면 충돌이 발생하므로, 이를 방지하기 위해 **다중 접근 프로토콜**이 필요하다. 이 프로토콜은 노드들이 언제 전송할 수 있는지를 스스로 결정하는 **분산 방식**으로 운영되며, 조정 메시지도 같은 채널을 통해 이루어진다.


## Where is the link layer implemented?

- 모든 호스트에 구현되어 있음
- 링크 계층은 **네트워크 인터페이스 카드(NIC)** 또는 칩에서 구현됨
    - 예: Ethernet 카드, WiFi 카드 또는 칩
    - 링크 계층과 물리 계층을 구현함
- 호스트의 시스템 버스(예: PCI 버스)에 연결됨    
- 하드웨어, 소프트웨어, 펌웨어의 조합으로 동작함

# 🔵 **간단 요약**

링크 계층은 **NIC(네트워크 인터페이스 카드)** 내부에서 구현되며, 하드웨어·소프트웨어·펌웨어가 함께 동작하여 링크 계층 및 물리 계층을 처리한다. 모든 호스트는 NIC를 통해 링크 계층 기능을 수행한다.


## Interfaces communicating

### 송신 측 (sending side):

- 데이터그램을 프레임으로 캡슐화함
- 오류 검출 비트, 신뢰적 데이터 전송, 흐름 제어 등의 정보를 프레임에 추가함

### 수신 측 (receiving side):

- 오류 여부·신뢰적 데이터 전송·흐름 제어 등을 확인함
- 데이터그램을 추출하여 상위 계층으로 전달함

# 🔵 **간단 요약**

송신 NIC는 **데이터그램을 프레임으로 감싸고**, 오류 검출 및 제어 정보를 추가하여 전송한다.  
수신 NIC는 **오류를 검사하고** 프레임에서 데이터그램을 꺼내 **네트워크 계층으로 전달**한다.



## MAC addresses

### ● 32-bit IP address:

- **네트워크 계층(network layer)의 주소**로 인터페이스를 식별함    
- **3계층(네트워크 계층)에서 패킷 전달에 사용됨**
- 예: **128.119.40.136**

### ● MAC 주소(=LAN 주소, 물리 주소, 이더넷 주소):

- 기능: **같은 서브넷(IP 관점에서 동일 네트워크)에 있는, 물리적으로 연결된 인터페이스 간 프레임을 전달할 때 _로컬(local)하게_ 사용됨**
- 대부분의 LAN은 **48비트 MAC 주소**를 사용하며, NIC의 ROM에 저장되어 있고 경우에 따라 소프트웨어로 변경 가능함
- 예: **1A-2F-BB-76-09-AD**  
    (16진수 표현, 각 숫자 하나가 4비트 의미)

# 🔵 **간단 요약**

- **IP 주소**는 3계층에서 **전 세계적으로 라우팅**할 때 사용됨.
- **MAC 주소**는 2계층에서 **같은 LAN 내부에서 프레임 전달**에 사용되는 로컬 주소임.
- MAC 주소는 48비트이며 보통 NIC에 내장됨.



## MAC addresses

LAN의 각 인터페이스는

- 고유한 **48비트 MAC 주소**를 가진다.
- (앞에서 보았듯이) **로컬하게 고유한 32비트 IP 주소**를 가진다.

(오른쪽 그림 설명:  
LAN 내부에서 각 컴퓨터는 서로 다른 MAC 주소와 IP 주소를 가지며, 예를 들어 137.196.7.78 / 1A-2F-BB-76-09-AD 와 같은 형태로 표시됨)

# 🔵 **간단 요약**

- LAN에 연결된 **모든 장치(인터페이스)는 MAC 주소가 항상 서로 달라야 함**.
- 동일 LAN 안에서도 각 장치는 **IP 주소도 서로 다름**(서브넷 내에서 유일).
- 즉, 하나의 장치는 **MAC + IP 두 주소를 모두 보유**하여 통신에 사용함.



## MAC addresses

- MAC 주소의 할당은 **IEEE가 관리**합니다.
- 제조사는 MAC 주소 공간의 일부를 **구매**하여(고유성을 보장하기 위해) 자신의 제품에 할당합니다.
- 비유:
    - MAC 주소: **주민등록번호**와 같음
    - IP 주소: **우편 주소**와 같음

- MAC 주소(flat address)의 이동성(portability):    
    - 하나의 인터페이스는 **한 LAN에서 다른 LAN으로 이동해도 MAC 주소는 그대로 유지**됩니다.
    - 기억할 점: IP 주소는 이동성이 없음 → 장치가 연결된 **IP 서브넷에 따라** 달라짐.

# 🔵 **간단 요약**

- MAC 주소는 IEEE가 관리하며 제조사가 일부 범위를 사서 제품에 씀.    
- MAC은 주민등록번호처럼 **영구적**이고, LAN을 옮겨도 그대로 유지됨.
- 반대로 IP 주소는 네트워크 환경(서브넷)에 따라 **바뀌는 주소**임.


## ARP: address resolution protocol

**질문:** IP 주소를 알고 있을 때, 어떻게 해당 인터페이스의 MAC 주소를 알아낼 수 있는가?

### ARP 테이블(ARP table):

- LAN에 있는 각 IP 노드(호스트, 라우터)는 **ARP 테이블**을 가진다.    
- 이 테이블에는 일부 LAN 노드들의 **IP 주소–MAC 주소 매핑 정보**가 저장되어 있다.  
    형식:  
    **<IP address; MAC address; TTL>**
- **TTL(Time To Live):**  
    주소 매핑이 얼마나 유지될지를 의미하며,  
    보통 **20분**이 지나면 항목은 삭제된다.

# 🔵 **간단 요약**

- ARP는 **IP 주소로 MAC 주소를 알아내는 프로토콜**이다.
- 각 장치는 ARP 테이블을 가지고 IP–MAC 매핑을 저장한다.
- 매핑은 TTL이 지나면 삭제되며 일반적으로 약 20분 유지된다.


## ARP: address resolution protocol

**질문:** IP 주소를 알고 있을 때, 해당 인터페이스의 MAC 주소를 어떻게 알아낼 수 있는가?

### ARP 테이블:

LAN에 있는 각 IP 노드(호스트, 라우터)는 ARP 테이블을 가진다.

- 일부 LAN 노드들에 대해 IP/MAC 주소 매핑 정보가 저장되어 있다.  
    **<IP address; MAC address; TTL>**    
- **TTL(Time To Live):**  
    주소 매핑이 일정 시간이 지나면 삭제되는 시간을 의미하며  
    일반적으로 **20분** 동안 유지된다.

# 🔵 **간단 요약**

- ARP는 **IP → MAC 주소 변환(protocol)** 기능을 수행한다.
- 각 장치는 ARP 테이블을 유지하며 IP–MAC 매핑과 TTL을 저장한다.
- 매핑은 일정 시간이 지나면 자동으로 삭제된다.

## ARP protocol in action

예: A가 B에게 데이터그램을 보내고자 하는 경우

- B의 MAC 주소가 A의 ARP 테이블에 없으므로, A는 ARP를 사용해 B의 MAC 주소를 찾는다    

### ① A가 ARP 요청(ARP query)을 브로드캐스트한다. (B의 IP 주소 포함)

- 목적지 MAC 주소 = FF-FF-FF-FF-FF-FF (브로드캐스트)
- LAN에 있는 모든 노드가 ARP 요청을 수신한다.

**이더넷 프레임 내용(브로드캐스트로 전송됨):**

- Sender MAC: 71-65-F7-2B-08-53
- Sender IP: 137.196.7.23
- Target MAC: 00-00-00-00-00-00 (알 수 없음)
- Target IP address: 137.196.7.14

### **② B는 자신의 MAC 주소를 제공하는 ARP 응답을 A에게 보낸다.**

### ③ A는 B의 응답을 수신하고, B의 항목을 자신의 로컬 ARP 테이블에 추가한다.
# 🔵 **간단 요약**

- A는 B의 MAC 주소를 모르기 때문에 ARP 요청을 **브로드캐스트**로 전송한다.
- 모든 장치가 이 ARP 요청을 받는다.
- 요청에는 "누가 IP 137.196.7.14을 가지고 있습니까?" 라는 정보가 담겨 있다.
- - B는 브로드캐스트로 온 ARP 요청을 보고 “그 IP는 나다”라고 판단한다.
- B는 **유니캐스트 ARP 응답**을 A에게 보내 MAC 주소를 알려준다.
- - A는 B가 보낸 ARP 응답을 받아서
- “B의 IP → B의 MAC” 매핑을 ARP 테이블에 저장하여
- 이후에는 ARP 없이 바로 MAC 주소를 사용해 전송할 수 있게 된다.



## **다른 서브넷으로 라우팅: 주소 지정**

**예시: A가 B에게 R(라우터)을 통해 데이터그램을 보내는 과정**

- **IP 계층(데이터그램)** 과 **MAC 계층(프레임)** 수준에서 주소 지정 과정을 설명함
- 다음을 가정함:
    - A는 **B의 IP 주소**를 알고 있음
    - A는 **첫 번째 홉 라우터 R의 IP 주소**를 알고 있음 _(어떻게 알까?)_
    - A는 **R의 MAC 주소**를 알고 있음 _(어떻게 알까?)_

그림:

- A(111.111.111.111, MAC: 74-29-9C-E8-FF-55)
- R(222.222.222.220, MAC: 1A-23-F9-CD-06-9B)
- B(222.222.222.222, MAC: 49-BD-D2-C7-56-2A)

# 🔵 **간단 요약**

- A가 B에게 보낼 때 **직접 B로 보내는 것이 아니라**,  
    **자신의 기본 게이트웨이(라우터 R)** 로 먼저 보낸다.    
- 그래서 A는:
    - B의 IP 주소만 알면 되고
    - 실제 프레임의 목적 MAC 주소는 **라우터 R의 MAC 주소**가 된다.
- R이 또 자신의 라우팅 테이블을 보고 B에게 전달함.


## **다른 서브넷으로 라우팅: 주소 지정**

- **A는 IP 데이터그램을 생성함**
    - IP 소스 주소: A
    - IP 목적지 주소: B
- **A는 A → B IP 데이터그램을 포함하는 링크 계층 프레임을 생성함**
    - 이때 프레임의 **목적 MAC 주소는 라우터 R의 MAC 주소**

프레임 내용(예시):
- **MAC src:** 74-29-9C-E8-FF-55
- **MAC dest:** E6-E9-00-17-BB-4B (A가 알고 있는 R의 MAC 주소)
- **IP src:** 111.111.111.111 (A)
- **IP dest:** 222.222.222.222 (B)

그림:  
A → 프레임 생성 → R로 전달  
R의 NIC MAC 주소: 1A-23-F9-CD-06-9B  
A가 가진 R의 MAC 주소: E6-E9-00-17-BB-4B  
(두 개 NIC가 있을 수 있으므로 MAC이 서로 다를 수 있음)

# 🔵 **간단 요약**

- **IP 목적지는 B이지만**,  
    **MAC 목적지는 R(기본 게이트웨이)** 이다.
- 즉,
    - **IP 레벨:** A → B   
    - **MAC 레벨:** A → R
- 이유:  
    B가 다른 서브넷에 있으므로 A는 직접 갈 수 없고  
    반드시 R을 통해야 하기 때문임.


