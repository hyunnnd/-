

# **Network-layer functions**

- **forwarding:**  
    라우터의 입력 포트로 들어온 패킷을 적절한 출력 포트로 이동시키는 기능  
    _(data plane)_
- **routing:**  
    패킷이 출발지에서 목적지까지 이동할 경로를 결정하는 기능  
    _(control plane)_

**네트워크 제어 평면을 구성하는 두 가지 접근 방식:**

- 라우터별 제어(per-router control, 전통적 방식)
- 논리적으로 중앙집중화된 제어(logically centralized control, 소프트웨어 정의 네트워킹)

# 🔹 설명

이 슬라이드는 **네트워크 계층에서 수행되는 두 가지 핵심 기능**을 구분하여 설명하고 있습니다.

## 1. Forwarding(데이터 플레인)

Forwarding은 라우터가 패킷을 받아서 **출력 인터페이스로 즉시 전달하는 동작**을 의미합니다.  
이는 라우터 내부에서 매우 빠르게 이루어져야 하며, 보통 하드웨어 수준에서 처리됩니다.  
즉, "들어온 패킷을 어디로 보낼 것인가"만 담당하는 기능입니다.

## 2. Routing(컨트롤 플레인)

Routing은 네트워크 전체를 바라보며 **패킷이 어떤 경로를 따라가야 할지 결정하는 기능**입니다.  
라우팅 알고리즘(RIP, OSPF, BGP 등)이 여기에 해당하며, 이를 통해 라우터는 포워딩 테이블을 구성합니다.

Forwarding과 Routing의 관계는 다음과 같습니다.

- Routing이 **경로를 계산**하고,    
- Forwarding이 그 계산 결과에 따라 **패킷을 실제로 전달**합니다.

## 3. 제어 평면 구성 방식 두 가지

### ① Per-router control (전통적인 방식)

각 라우터가 자신의 라우팅 알고리즘을 직접 수행하여  
독립적으로 라우팅 테이블을 구성하는 방식입니다.  
즉, 모든 라우터가 스스로 판단합니다.

### ② Logically centralized control (SDN)

소프트웨어 정의 네트워킹(SDN) 방식에서는  
**중앙 컨트롤러(SDN controller)**가 전체 네트워크를 논리적으로 관리하며  
라우터(스위치)는 단순히 forwarding만 수행합니다.

이 방식은 다음 장점이 있습니다.

- 네트워크 전체의 상태를 중앙에서 한 번에 파악
- 제어 정책 변경이 매우 용이
- 자동화와 프로그래밍이 쉬움


# 🔹 번역

**Routing protocols**

**Routing protocol goal:**  
라우팅 프로토콜의 목표는 송신 호스트에서 수신 호스트까지 패킷이 지나가는 경로(또는 route)를 결정하는 것이며, 이는 여러 라우터로 구성된 네트워크를 통해 이루어짐.

- **path:**  
    특정 출발지 호스트에서 목적지 호스트까지 패킷이 통과해야 하는 라우터들의 순서(시퀀스)
- **“good”:**  
    비용(cost)이 가장 적거나, 가장 빠르거나(fastest), 혼잡이 가장 적은(least congested) 경로
- **routing:**  
    네트워킹 분야에서 가장 어려운 문제 중 하나(“top-10” challenge)

# 🔹 설명

이 슬라이드는 **라우팅 프로토콜이 무엇을 목표로 하는지**와  
“좋은 경로”가 어떤 조건을 의미하는지를 설명하고 있습니다.

## 1. 라우팅 프로토콜의 목표

라우팅 프로토콜은 네트워크 안에서 **최적의 경로를 계산하는 알고리즘**을 말합니다.  
예: RIP, OSPF, BGP 등.

송신 호스트에서 목적지 호스트까지 데이터를 보내기 위해  
수많은 라우터를 거쳐 가야 하는데, 이 경로를 **자동으로 선택**해 주는 것이 핵심 기능입니다.

네트워크가 매우 복잡할 수 있으므로  
각 라우터는 라우팅 프로토콜을 통해 서로 정보를 교환하며  
“어느 방향으로 패킷을 보내야 가장 좋은지”를 결정합니다.

## 2. Path의 의미

Path는 단순히 “출발 → 도착”이 아니라,  
그 사이에 위치한 여러 라우터들의 **연속된 목록**을 뜻합니다.

예)  
Host A → R1 → R3 → R5 → R8 → Host B

이 전체가 path입니다.

## 3. “좋은” 경로의 기준

라우팅 프로토콜은 가능한 많은 경로들 중에서  
가장 “좋은(good)” 경로를 선택해야 합니다.

“good”의 기준은 네트워크 설계에 따라 달라질 수 있습니다.

- **least cost:**  
    링크 비용이 가장 낮은 경로  
    (전통적 라우팅 알고리즘에서 많이 사용)    
- **fastest:**  
    지연(latency)이 가장 짧은 경로
- **least congested:**  
    혼잡이 적고 패킷 손실 가능성이 낮은 경로  
    (부하 기반 라우팅 등)

라우팅 알고리즘에 따라 이러한 기준을 조합해 사용하기도 합니다.

## 4. 라우팅은 매우 어려운 문제

슬라이드에서 “top-10 networking challenge”라고 강조한 이유는  
라우팅이 단순히 짧은 길을 찾는 문제가 아니라,

- 네트워크 규모가 매우 크고    
- 링크 상태가 시시각각 변하고
- 트래픽 부하가 계속 변동하고
- 서로 다른 ISP가 각자의 정책을 적용하고

이러한 이유로 **전 세계적으로 라우팅을 설계하고 운영하는 것은 매우 복잡한 문제**이기 때문입니다.

특히 인터넷 백본에서 사용되는 BGP는  
전 세계 네트워크 사업자들이 서로 정책적·경제적 이유로 경로를 선택하기 때문에  
기술적 + 정책적 복잡성이 극도로 높습니다.



# 🔹 번역

**Graph abstraction: link costs**

- ca,bc_{a,b}ca,b​: 라우터 aaa와 bbb를 직접(direct) 연결하는 링크의 비용(cost)  
    예:  
    cw,z=5c_{w,z} = 5cw,z​=5,  
    cu,z=∞c_{u,z} = \inftycu,z​=∞
- 이 비용은 네트워크 운영자가 정의하며, 항상 1로 설정할 수도 있고,  
    **대역폭에 반비례**하거나 **혼잡도에 반비례**하도록 설정할 수도 있음.    
- **그래프 G = (N, E)**
    - NNN: 라우터 집합 = { u, v, w, x, y, z }
    - EEE: 링크 집합 =  
        {(u,v), (u,x), (v,x), (v,w), (x,w), (x,y), (w,y), (w,z), (y,z)}

# 🔹 설명

이 슬라이드는 **라우팅 문제를 그래프(Graph)로 모델링하는 방법**을 설명하고 있습니다.

## 1. 라우터를 그래프의 노드(node)로 표현

라우터는 그래프에서 **정점(vertex)** 으로 나타냄.  
예: 라우터 u, v, w, x, y, z → 그래프 노드 6개.

이렇게 하면 복잡한 네트워크도 수학적으로 단순하게 분석 가능해짐.

## 2. 링크는 그래프의 간선(edge)

두 라우터를 연결하는 **링크(link)** 는  
그래프에서는 **간선(edge)** 으로 표시함.

예: (u, v), (v, w), (w, z) 등.

이 간선에는 **비용(cost)** 이 존재하며, 슬라이드에서는 숫자로 표시됨.

## 3. 링크 비용(link cost)의 의미

링크 비용은 네트워크 운영자가 필요에 따라 설정함.

- 항상 1로 설정  
    → 최소 홉(hop) 라우팅과 같음    
- **대역폭에 반비례**  
    → 대역폭이 넓은 링크의 비용을 낮게 설정  
    → 고속 링크를 더 많이 사용함
- **혼잡도(congestion)에 반비례**  
    → 혼잡한 링크는 비용이 높아짐  
    → 트래픽이 적은 경로로 우회하게 됨

## 4. 비용이 ∞(무한대)라는 의미

예: cu,z=∞c_{u,z} = \inftycu,z​=∞

이는 **u와 z 사이에는 직접 연결된 링크가 없음을 의미**함.

무한대 비용 → 사용 불가능한 링크 → 그래프에서는 “직접 연결 없음”과 같음.

## 5. 왜 그래프로 표현하는가?

라우팅 알고리즘(예: 다익스트라 알고리즘, 벨만-포드)이  
이러한 그래프 모델을 기반으로 최적 경로를 계산하기 때문입니다.

- 노드 = 라우터    
- 간선 = 링크
- 비용 = 링크 품질(거리/속도/혼잡도 등)

이렇게 모델링하면 “최단 경로 문제”로 변환되어  
수학적으로 경로 계산을 수행할 수 있습니다.


# 🔹 번역

**Routing algorithm classification**

- **global:** 모든 라우터가 전체(topology, link cost) 정보를 알고 있음
    - “link state” 알고리즘
- **decentralized:** 이웃 라우터와 정보 교환을 반복하며 경로를 계산하는 방식
    - 라우터는 처음에 자신과 직접 연결된 링크 비용만 알고 있음
    - “distance vector” 알고리즘
- **static:** 경로가 시간에 따라 매우 천천히 변함
- **dynamic:** 경로가 더 빠르게 변함
    - 정기적인 업데이트 또는 링크 비용 변화에 반응하여 업데이트

(좌→우: 경로 변화 속도, 아래→위: 정보 공유 범위: 분산 ↔ 전역)

# 🔹 설명

이 슬라이드는 **라우팅 알고리즘을 분류하는 두 가지 기준**을 설명하고 있다.

## 1. 첫 번째 기준: **정보가 어느 범위까지 공유되는가? (global vs decentralized)**

### ✔ Global routing (전역적 라우팅)

- 네트워크 전체의 링크 구조(topology)와 비용 정보를 모든 라우터가 알고 있음.    
- 중앙 집권적인 방식.
- 대표 알고리즘: **Link State(LS)**  
    → OSPF 같은 프로토콜이 여기에 해당함.

➡ 특징

- 모든 라우터가 전체 그림을 알고 있으므로  
    **최단 경로 계산 정확도가 높고 수렴 속도가 빠름.**

### ✔ Decentralized routing (분산 라우팅)

- 이웃 라우터끼리만 정보를 주고받으며 경로를 계산.    
- 네트워크 전체 정보를 한 번에 알지 못함.
- 대표 알고리즘: **Distance Vector(DV)**  
    → RIP 프로토콜 등이 여기에 해당함.

➡ 특징

- 계산 과정이 반복적(iterative)이고
- 이웃의 정보만 보고 경로를 결정하므로  
    **오류 전파나 수렴 지연 가능성이 있음.**

## 2. 두 번째 기준: **경로가 얼마나 빨리 바뀌는가? (static vs dynamic)**

### ✔ Static routing (정적 라우팅)

- 경로가 거의 변하지 않음    
- 사람이 수동으로 설정하거나 매우 드물게 업데이트됨
- 변화가 적은 환경에서 사용됨 (예: 작은 기업 네트워크)

### ✔ Dynamic routing (동적 라우팅)

- 네트워크 상태 변화(링크 장애, 혼잡 등)에 따라  
    **빠르게 경로를 재계산**하는 방식    
- 주기적인 업데이트 또는 이벤트 기반 업데이트 수행
- 대부분의 현대 네트워크에서 사용됨

## 🔹 전체 그림 정리(설명용)

좌우 축, 상하 축을 조합하면 아래와 같은 분류가 생긴다.

| 분류                          | 의미                                   |
| --------------------------- | ------------------------------------ |
| **Global + Dynamic**        | 전체 정보를 빠르게 공유하며 경로를 빠르게 조정 (예: OSPF) |
| **Global + Static**         | 전체 구조는 알지만 경로는 자주 바꾸지 않음             |
| **Decentralized + Dynamic** | 이웃 정보 기반으로 빠르게 갱신 (예: RIP)           |
| **Decentralized + Static**  | 이웃 정보 기반이지만 거의 변하지 않음                |


# 🔹 **번역**

## **Dijkstra’s link-state routing algorithm**

- **centralized:** 네트워크 토폴로지와 링크 비용이 모든 노드에 알려져 있음
    - “링크 상태 브로드캐스트(link state broadcast)”를 통해 이루어짐
    - 모든 노드는 동일한 정보를 가짐
- **computes least cost paths:** 한 노드(“source”)로부터 다른 모든 노드까지
    - 이 계산 결과는 해당 노드의 **forwarding table(포워딩 테이블)**을 만듦
- **iterative:**  
    k번 반복(iteration) 후에는 **k개의 목적지까지의 최단 비용 경로**가 확정됨

# 🔹 **notation(표기법)**

- **cₓᵧ:**  
    노드 x와 y 사이의 **직접 링크 비용**  
    (직접 연결되지 않았다면 비용은 ∞ 로 둔다)    
- **D(v):**  
    출발 노드에서 목적지 v까지의 **현재 추정된 최소 비용**
- **p(v):**  
    출발지에서 v까지 가는 “경로 상 바로 이전 노드”  
    (즉, v의 predecessor)
- **N′:**  
    **최단 경로가 확정된 노드들의 집합**  
    (이미 정확한 최소 비용을 아는 노드 집합)

# 🔹 **설명**

이 슬라이드는 **링크 상태(Link State) 기반 라우팅**에서 핵심 알고리즘인 **다익스트라(Dijkstra) 알고리즘**의 개념을 설명하고 있다.

## ✔ 왜 “centralized”인가?

링크 상태 라우팅은  
각 노드가 **네트워크 전체 구조**와 **모든 링크 비용**을 정확히 알고 있어야 한다.

- 각 라우터는 자신과 연결된 링크 정보를 브로드캐스트로 네트워크 전체에 전달    
- 모든 라우터가 동일한 “전역 지도”를 갖게 됨
- 결국 각 라우터는 **독립적으로** 다익스트라 알고리즘을 수행하여  
    자신만의 최단 경로 트리를 만든다.

즉, 분산 네트워크이지만 **정보는 전역적으로 공유되는 구조**이므로 “centralized”라고 표현한다.

## ✔ 다익스트라의 핵심 개념들

### 1) **N′ (확정 집합)**

- 이미 최단 경로가 확정된 노드들의 집합    
- 반복(iteration)마다 이 집합이 하나씩 커짐

### 2) **D(v) (거리 추정값)**

- 아직 확정되지 않은 노드들에 대해  
    현재까지 알고 있는 “가장 좋은 경로 비용”

### 3) **p(v)**

- D(v)를 제공해 준 경로에서  
    v 이전 노드를 기록해 두는 것
- 나중에 최단 경로를 역추적하기 위해 필요

## ✔ 왜 iterative인가?

다익스트라는 한 번에 전체를 계산하지 않는다.

- 첫 반복에서는 출발지와 가장 가까운 노드 하나만 확정    
- 다음 반복에서는 두 번째로 가까운 노드를 확정
- 이런 방식으로 **한 번의 반복 = 한 노드의 최단 경로 확정**

그래서 k번 반복하면 최소 k개의 목적지에 대한 최단 경로를 알 수 있다.


# 🔹 **번역**

## **Dijkstra’s algorithm: discussion**

### **algorithm complexity:** n개의 노드

- n번의 반복(iteration) 동안,  
    각 반복마다 **N 집합에 포함되지 않은 모든 노드 w**를 검사해야 함
- 전체 비교 횟수 = n(n+1)/2 → **O(n²)**
- 더 효율적인 구현(예: 힙 사용)도 가능하며, 이 경우 **O(n log n)**

### **message complexity:**

- 각 라우터는 자신의 링크 상태 정보를 **다른 n개의 라우터에게 브로드캐스트**해야 함    
- 효율적인(또는 흥미로운) 브로드캐스트 알고리즘은  
    하나의 노드로부터의 브로드캐스트 메시지를 모든 노드에 전달하는 데  
    **O(n)** 개의 링크 통과(link crossings)을 필요로 함
- 각 라우터의 메시지는 **O(n)** 개의 링크를 통과하므로  
    전체 메시지 복잡도는 **O(n²)**

## 📘 **Dijkstra 알고리즘: 경로 진동 가능성**

- 링크 비용이 **트래픽 양에 따라 달라지는 경우**, 경로가 계속 바뀌는 **route oscillation(경로 진동)**이 발생할 수 있음
- 예시 시나리오:
    - 목적지 a로 라우팅할 때, b·c·d에서 각각 트래픽이 1, e(<1), 1만큼 유입됨
    - 링크 비용은 **방향성이 있고**, **트래픽 양에 따라 변화**함
- 해결책:
    - 모든 라우터가 동시에 링크 상태(LS) 알고리즘을 실행하지 않도록 함

## 📘 Distance Vector 알고리즘

**Bellman-Ford(BF) 방정식**(동적 프로그래밍)에 기반함:

### 🟥 Bellman-Ford 방정식

노드 x에서 y까지의 최소 비용 경로의 비용을  
**Dₓ(y)** 라고 하면,

D_x(y)=min_⁡v(c_x,v+D_v(y))

여기서:

- **cₓ,ᵥ** : x에서 이웃 v까지의 직접 링크 비용
- **Dᵥ(y)** : 이웃 v가 알고 있는 y까지의 최소 경로 비용
- **min** : x의 **모든 이웃 v** 중에서 최소값 선택


### 📘 Bellman-Ford 예시

u의 이웃 노드 **x, v, w** 가 목적지 **z**까지의 비용을 아래처럼 알고 있다고 가정하자:

- **Dᵥ(z) = 5**
- **Dₓ(z) = 3**
- **D_w(z) = 3**

### 🟥 Bellman-Ford 방정식을 적용하면:

D_u(z)=min⁡{c_u,v+Dv_(z),  c_u,x+D_x(z),  c_u,w+D_w(z)}

각 항을 계산하면:

- u→v 비용: **2 + 5 = 7**
- u→x 비용: **1 + 3 = 4**
- u→w 비용: **5 + 3 = 8**

따라서:

D_u(z)=4

### ✔ 최소값을 만든 노드(x)가

u가 목적지 **z**로 가기 위한 **다음 홉(next hop)** 이 됨.
(즉, u는 z까지 가는 최소 비용 경로로 x를 선택함)


### 📘 Distance Vector Algorithm — 번역

**핵심 아이디어:**

- 일정 시간마다 각 노드는 자신의 **distance vector(거리 벡터)** 추정값을 이웃에게 보낸다.
- 노드 **x**가 이웃으로부터 새로운 거리 벡터 값을 받으면, Bellman-Ford 방정식을 사용해 자신의 DV를 갱신한다:

D_x(y)←min⁡v{c_x,v+D_v(y)}(모든 목적지 y∈N)
- 경로 비용이 시간이 지나며 조금씩 변해도, 자연스러운 조건하에서는  
    **Dₓ(y)** 값이 실제 최소 비용 **dₓ(y)** 로 수렴한다.


### 📘 Distance Vector Algorithm — 번역

**각 노드는 다음을 수행함:**

1. **기다림(wait):**
    - 로컬 링크 비용이 변하거나
    - 이웃으로부터 메시지가 도착할 때까지 기다린다.
2. **재계산(recompute):**
    - 이웃에게서 받은 DV를 사용해 자신의 DV 추정값을 다시 계산한다.
3. **알림(notify):**
    - 어떤 목적지에 대한 DV 값이 바뀌면  
        이웃 노드들에게 변경 사실을 알린다.

### 추가 특성

**반복적(iterative), 비동기적(asynchronous):**

- 각 노드의 연산(iteration)은 다음 두 사건 중 하나로 인해 발생한다:    
    - 로컬 링크 비용 변화
    - 이웃으로부터 DV 업데이트 메시지 수신

**분산(distributed), 자동 중단(self-stopping):**

- 노드는 자신의 DV가 실제로 변했을 때만 이웃에게 알린다.    
- 이웃 노드는 필요할 때만 다시 그 이웃에게 알린다.
- 변경이 없다면 어떤 노드도 아무 행동을 하지 않는다.

### **1) Distance Vector Example (b가 a, c, e로부터 DV 수신)**

- b 노드는 a, c, e 노드의 DV를 받아서  
    **Bellman-Ford 식으로 b 자신의 DV 값을 갱신**함.
- 갱신 결과:  
    Db(a)=8, Db(c)=1, Db(d)=2, Db(e)=1, Db(f)=2    

### **2) Distance Vector Example (b가 DV 계산 과정 상세)**

- 실제 수식으로 b가 각 목적지까지 최소 비용을 계산하는 과정 표시.
- DV 갱신 후 b의 DV는 위와 동일하게 결정됨.    

### **3) Distance Vector Example (c가 b의 DV를 수신 후 계산)**

- c는 b의 DV를 받아 Bellman-Ford 식 수행.    
- 갱신 결과:  
    Dc(a)=9, Dc(b)=1, Dc(d)=∞, Dc(e)=2

### **4) Distance Vector Example (e가 b, d, f, h로부터 DV 수신)**

- e는 이웃 b, d, f, h 의 DV를 받아 **모든 목적지 비용을 재계산**함.    
- e는 d와 f, h의 경로 정보를 이용해 비용을 낮출 수 있음.

### **5) Distance Vector Another Example (x, y, z 간 DV 교환 1단계)**

- x, y, z 세 노드가 처음 DV를 교환한 뒤  
    **x는 y를 통해 z로 가는 비용(=3)** 을 계산함.    
- x→y→z 경로(2+1)가 직접 연결 비용(7)보다 짧음.

### **6) Distance Vector Another Example (DV 반복 교환 후 수렴)**

- DV가 계속 교환되며 값이 점차 **최소 비용으로 수렴**함.
- 최종적으로 x, y, z 모두 정확한 최소 비용 값을 가지게 됨.



## ✔ Distance vector: state information diffusion (간단 설명)

**개념:**  
Distance Vector 알고리즘에서는 한 노드의 정보가 이웃 → 이웃의 이웃 → … 이런 식으로 **점진적으로 네트워크 전체로 퍼져나감**.

### **t = 0**
- c 노드의 정보는 **c 본인만 알고 있음**.
### **t = 1**
- c → b 로 정보가 전달됨.
- 즉, **1-hop 떨어진 노드(b)** 까지가 영향을 받음.
### **t = 2**
- b가 가진 정보가 a, e로 전달됨.
- 즉, c의 정보가 **2-hop 노드(a, e)** 까지 확산됨.
### **t = 3**
- 정보가 d, f, h까지 확산됨.
- 즉, **3-hop 노드들**이 영향을 받기 시작함.
### **t = 4**
- 정보가 g, i까지 도달함.
- 즉, **4-hop 떨어진 네트워크 전체**에 정보가 퍼짐.
## ✔ 핵심 요약 한 줄

**DV 알고리즘에서는 한 노드의 상태 변화가 hop-by-hop 방식으로 시간에 따라 점차 네트워크 전체로 전파된다.**



## ✔ Distance vector: link cost changes (간단 설명)

### **상황**

- y–x 링크 비용이 **변경됨(↓ 감소)**.
- Distance Vector 알고리즘은 **좋은 소식(good news)**(비용 감소)이 빠르게 전파됨.

### **t₀**
- y가 **링크 비용 변화 감지**.
- y는 **자신의 DV를 갱신**하고 **이웃에게 알림**.

### **t₁**
- z가 y로부터 DV 업데이트를 받음.
- z는 **x까지의 더 짧은 경로를 계산**해 DV 갱신.
- 갱신된 DV를 다시 **이웃에게 전파**.
### **t₂**
- y는 다시 z의 업데이트를 받지만,  
    z의 정보가 y의 DV를 **더 이상 개선하지 못함**.
- 따라서 y는 **추가 전송을 하지 않음**.
## ✔ 핵심 한 줄 정리

**링크 비용이 줄어드는 ‘좋은 소식’은 DV 알고리즘에서 매우 빠르게 네트워크 전체에 전파된다.**
필요하시면 이 예시의 실제 숫자 계산 과정도 따로 정리해 드릴까요?


## ✔ Distance vector: link cost changes — “bad news travels slow”

### **핵심 상황**

- y–x 링크의 비용이 **4 → 60**으로 증가함(= 나빠짐).
- Distance Vector는 **나쁜 소식이 매우 느리게 전파됨** → Count-to-infinity 문제.

## ✔ 전개 과정(간단 설명)

### **1) y가 링크 비용 증가 감지**

- 직접 경로 비용 = **60**
- 하지만 z는 “나는 x까지 비용 **5**에 갈 수 있어”라고 알려줬었음.
- 그래서 y는 잘못 계산함:  
    → “z를 거치면 **6**이네!”(60보다 작으니까)
- y는 z에게 비용 6을 알림.

### **2) z가 y의 정보로 잘못된 계산 시작**
- z: “y를 거치면 x까지 **7**이네!”
- z는 y에게 7을 알림.

### **3) y도 또 잘못된 계산 반복**
- y: “z를 거치면 **8**이네!”
- y는 z에게 8을 알림.

### **4) 또 반복…**
- z: “그럼 나는 **9**네!”
- y: “나는 **10**이네!”
- 이렇게 계속 증가함 → 사실상 **무한대로 증가(count-to-infinity)**

## ✔ 핵심 한 줄 설명

**나쁜 소식(비용 증가)은 DV 알고리즘에서 매우 느리게 퍼지며, 서로 잘못된 정보만 교환하다가 비용이 무한대로 증가하는 문제가 생긴다.**


## **LS와 DV 알고리즘 비교**

### **message complexity (메시지 복잡도)**

**LS:**
- 라우터 수가 n개일 때,
- O(n²) 메시지가 전송됨

**DV:**
- 이웃 간 거리 벡터 교환
- 수렴(convergence) 시간은 상황에 따라 달라짐

### **speed of convergence (수렴 속도)**

**LS:**
- O(n²) 알고리즘, O(n²) 메시지
- 진동(oscillation)이 발생할 수 있음

**DV:**
- 수렴 시간은 상황에 따라 달라짐
- 라우팅 루프가 생길 수 있음
- count-to-infinity 문제 발생

### **robustness (견고성): 라우터가 오작동하거나 공격받으면?**

**LS:**
- 라우터가 잘못된 **링크 비용(link cost)** 을 광고(advertise)할 수 있음
- 각 라우터는 자신의 포워딩 테이블만 계산함

**DV:**
- DV 라우터는 잘못된 **경로 비용(path cost)** 을 광고할 수 있음  
    (“나는 모든 곳으로 매우 낮은 비용으로 갈 수 있어!”) → 블랙홀(black-holing) 문제
- 각 라우터의 테이블이 다른 라우터의 계산에 쓰이므로  
    → 오류가 네트워크 전체로 전파됨


## **라우팅을 확장 가능하게 만들기**

지금까지의 라우팅 연구 - 이상화된 모델
- 모든 라우터는 동일함
- 네트워크는 "평면적"

... 실제로는 그렇지 않음

**규모: 수십억 개의 목적지:**

- 라우팅 테이블에 모든 목적지를 저장할 수 없음!
- 라우팅 테이블 교환은 링크를 압도할 것임!

**관리적 자율성:**

- 인터넷: 네트워크들의 네트워크
- 각 네트워크 관리자는 자신의 네트워크 내에서 라우팅을 제어하고 싶어할 수 있음


## **확장 가능한 라우팅을 위한 인터넷 접근법**

라우터들을 "자율 시스템" (AS) 또는 "도메인"으로 알려진 지역으로 집합화
**intra-AS (또는 "intra-domain"):** 동일한 AS 내에서의 라우팅
- AS 내의 모든 라우터는 동일한 intra-domain 프로토콜을 실행해야 함
- 다른 AS의 라우터들은 서로 다른 intra-domain 라우팅 프로토콜을 실행할 수 있음
- **게이트웨이 라우터:** 자율 시스템의 "경계"에 위치하며, 다른 AS와 연결된 라우터와 링크를 가짐

**inter-AS (또는 "inter-domain"):** AS 간의 라우팅
- 게이트웨이는 inter-domain 라우팅(및 intra-domain 라우팅) 수행


## **상호 연결된 AS들**

**포워딩 테이블:** intra-AS 및 inter-AS 라우팅 알고리즘에 의해 구성됨
- **intra-AS 라우팅**은 AS 내의 목적지에 대한 항목을 결정함
- **inter-AS 및 intra-AS**는 외부 목적지에 대한 항목을 결정함

**intra-AS 라우팅**: AS 내에서의 라우팅  
**inter-AS 라우팅**: AS 간의 라우팅

각 AS는 자체적인 라우팅을 수행하고, 외부 목적지에 대한 라우팅은 상호 연결된 AS들의 라우팅 테이블에 의해 결정됨.


## **Inter-AS 라우팅: 도메인 내 포워딩에서의 역할**

- **가정:** AS1의 라우터가 AS1 외부로 가는 데이터그램을 수신한다고 가정
    - 라우터는 패킷을 AS1의 게이트웨이 라우터로 전달해야 하지만, 어떤 게이트웨이로 전달해야 할까요?

**AS1의 inter-domain 라우팅은 다음을 수행해야 합니다:**

1. AS2를 통해 도달 가능한 목적지와 AS3를 통해 도달 가능한 목적지를 학습
2. 이 도달 가능성 정보를 AS1 내의 모든 라우터에 전파

이 과정에서 inter-domain 라우팅은 각 AS 간의 경로를 알리고 이를 AS1 내 모든 라우터에게 전달하는 역할을 합니다.



## **Inter-AS 라우팅: AS 내에서의 라우팅**

가장 일반적인 intra-AS 라우팅 프로토콜:

- **RIP: 라우팅 정보 프로토콜 [RFC 1723]**
    - 고전적인 DV: 30초마다 DV 교환
    - 더 이상 널리 사용되지 않음

- **EIGRP: 향상된 내부 게이트웨이 라우팅 프로토콜**    
    - DV 기반
    - 수십 년 동안 Cisco 독점 프로토콜이었으나 2013년 [RFC 7868]에서 공개됨

- **OSPF: 개방형 최단 경로 우선 [RFC 2328]**    
    - 링크 상태 라우팅
    - IS-IS 프로토콜 (ISO 표준, RFC 표준 아님)으로, 본질적으로 OSPF와 동일


## **OSPF (Open Shortest Path First) 라우팅**

- **“open”**: 공개적으로 이용 가능
- **고전적인 링크 상태**
    - 각 라우터는 OSPF 링크 상태 광고를 전체 AS의 다른 라우터들에게 직접 IP를 통해 전파 (TCP/UDP 대신)
    - 여러 링크 비용 메트릭 가능: 대역폭, 지연
    - 각 라우터는 전체 토폴로지를 가지고 있으며, Dijkstra 알고리즘을 사용하여 포워딩 테이블을 계산
- **보안**: 모든 OSPF 메시지는 인증되어 악의적인 침입을 방지함


## **계층적 OSPF**

- **두 수준 계층**: 로컬 영역, 백본
    - 링크 상태 광고는 영역 내 또는 백본에만 전파됨
    - 각 노드는 자세한 영역 토폴로지를 가지고 있으며, 다른 목적지로 가는 방향만 알고 있음

**영역 경계 라우터:**

- 자신의 영역 내 목적지로 가는 거리를 "요약"하여 백본에 광고

**로컬 라우터:**

- 해당 영역 내에서만 링크 상태를 전파
- 영역 내에서 라우팅 계산
- 영역 경계 라우터를 통해 외부로 패킷 전송

**백본 라우터:**

- 백본에 제한된 OSPF를 실행

**경계 라우터:**

- 다른 AS와 연결


## **인터넷 inter-AS 라우팅: BGP**

- **BGP (Border Gateway Protocol):** 사실상의 inter-domain 라우팅 프로토콜
    - "인터넷을 하나로 묶는 접착제"
- 서브넷이 자신의 존재와 도달할 수 있는 목적지를 인터넷의 나머지 부분에 광고할 수 있게 해줌: "나는 여기 있고, 내가 도달할 수 있는 곳은 여기이며, 방법은 이렇다"

**BGP는 각 AS에 다음과 같은 기능을 제공:**

- **eBGP:** 이웃 AS로부터 서브넷 도달 가능성 정보를 받음
- **iBGP:** 모든 AS 내의 라우터들에게 도달 가능성 정보를 전파
- 다른 네트워크로 가는 "좋은" 경로를 도달 가능성 정보와 정책에 따라 결정


## **eBGP, iBGP 연결**

- **eBGP 연결 (빨간색)**: AS 간의 연결
- **논리적 iBGP 연결 (파란색)**: 동일한 AS 내의 라우터 간 연결

**설명:**

- **게이트웨이 라우터**는 eBGP와 iBGP 프로토콜을 모두 실행합니다.
- 그림에서 각 AS(AS1, AS2, AS3)는 서로 다른 라우터들로 구성되며, AS 간에는 eBGP 연결이, AS 내에서는 iBGP 연결이 설정되어 있습니다.


## **BGP 기본**

- **BGP 세션:** 두 BGP 라우터 ("피어")가 반영구적인 TCP 연결을 통해 BGP 메시지를 교환:
    - 다양한 목적지 네트워크 접두사에 대한 경로를 광고 (BGP는 "경로 벡터" 프로토콜)

- **AS3의 게이트웨이 3a가 AS2의 게이트웨이 2c에 경로 AS3,X를 광고할 때:**    
    - AS3는 AS2에게 X로 향하는 데이터그램을 전달할 것이라고 **약속**함

BGP는 경로 광고를 통해 네트워크 간 경로 정보를 공유하고, 이를 통해 다른 네트워크로의 데이터 전달을 보장합니다.



