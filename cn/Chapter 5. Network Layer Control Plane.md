

# **Network-layer functions**

- **forwarding:**  
    라우터의 입력 포트로 들어온 패킷을 적절한 출력 포트로 이동시키는 기능  
    _(data plane)_
- **routing:**  
    패킷이 출발지에서 목적지까지 이동할 경로를 결정하는 기능  
    _(control plane)_

**네트워크 제어 평면을 구성하는 두 가지 접근 방식:**

- 라우터별 제어(per-router control, 전통적 방식)
- 논리적으로 중앙집중화된 제어(logically centralized control, 소프트웨어 정의 네트워킹)

# 🔹 설명

이 슬라이드는 **네트워크 계층에서 수행되는 두 가지 핵심 기능**을 구분하여 설명하고 있습니다.

## 1. Forwarding(데이터 플레인)

Forwarding은 라우터가 패킷을 받아서 **출력 인터페이스로 즉시 전달하는 동작**을 의미합니다.  
이는 라우터 내부에서 매우 빠르게 이루어져야 하며, 보통 하드웨어 수준에서 처리됩니다.  
즉, "들어온 패킷을 어디로 보낼 것인가"만 담당하는 기능입니다.

## 2. Routing(컨트롤 플레인)

Routing은 네트워크 전체를 바라보며 **패킷이 어떤 경로를 따라가야 할지 결정하는 기능**입니다.  
라우팅 알고리즘(RIP, OSPF, BGP 등)이 여기에 해당하며, 이를 통해 라우터는 포워딩 테이블을 구성합니다.

Forwarding과 Routing의 관계는 다음과 같습니다.

- Routing이 **경로를 계산**하고,    
- Forwarding이 그 계산 결과에 따라 **패킷을 실제로 전달**합니다.

## 3. 제어 평면 구성 방식 두 가지

### ① Per-router control (전통적인 방식)

각 라우터가 자신의 라우팅 알고리즘을 직접 수행하여  
독립적으로 라우팅 테이블을 구성하는 방식입니다.  
즉, 모든 라우터가 스스로 판단합니다.

### ② Logically centralized control (SDN)

소프트웨어 정의 네트워킹(SDN) 방식에서는  
**중앙 컨트롤러(SDN controller)**가 전체 네트워크를 논리적으로 관리하며  
라우터(스위치)는 단순히 forwarding만 수행합니다.

이 방식은 다음 장점이 있습니다.

- 네트워크 전체의 상태를 중앙에서 한 번에 파악
- 제어 정책 변경이 매우 용이
- 자동화와 프로그래밍이 쉬움


# 🔹 번역

**Routing protocols**

**Routing protocol goal:**  
라우팅 프로토콜의 목표는 송신 호스트에서 수신 호스트까지 패킷이 지나가는 경로(또는 route)를 결정하는 것이며, 이는 여러 라우터로 구성된 네트워크를 통해 이루어짐.

- **path:**  
    특정 출발지 호스트에서 목적지 호스트까지 패킷이 통과해야 하는 라우터들의 순서(시퀀스)
- **“good”:**  
    비용(cost)이 가장 적거나, 가장 빠르거나(fastest), 혼잡이 가장 적은(least congested) 경로
- **routing:**  
    네트워킹 분야에서 가장 어려운 문제 중 하나(“top-10” challenge)

# 🔹 설명

이 슬라이드는 **라우팅 프로토콜이 무엇을 목표로 하는지**와  
“좋은 경로”가 어떤 조건을 의미하는지를 설명하고 있습니다.

## 1. 라우팅 프로토콜의 목표

라우팅 프로토콜은 네트워크 안에서 **최적의 경로를 계산하는 알고리즘**을 말합니다.  
예: RIP, OSPF, BGP 등.

송신 호스트에서 목적지 호스트까지 데이터를 보내기 위해  
수많은 라우터를 거쳐 가야 하는데, 이 경로를 **자동으로 선택**해 주는 것이 핵심 기능입니다.

네트워크가 매우 복잡할 수 있으므로  
각 라우터는 라우팅 프로토콜을 통해 서로 정보를 교환하며  
“어느 방향으로 패킷을 보내야 가장 좋은지”를 결정합니다.

## 2. Path의 의미

Path는 단순히 “출발 → 도착”이 아니라,  
그 사이에 위치한 여러 라우터들의 **연속된 목록**을 뜻합니다.

예)  
Host A → R1 → R3 → R5 → R8 → Host B

이 전체가 path입니다.

## 3. “좋은” 경로의 기준

라우팅 프로토콜은 가능한 많은 경로들 중에서  
가장 “좋은(good)” 경로를 선택해야 합니다.

“good”의 기준은 네트워크 설계에 따라 달라질 수 있습니다.

- **least cost:**  
    링크 비용이 가장 낮은 경로  
    (전통적 라우팅 알고리즘에서 많이 사용)    
- **fastest:**  
    지연(latency)이 가장 짧은 경로
- **least congested:**  
    혼잡이 적고 패킷 손실 가능성이 낮은 경로  
    (부하 기반 라우팅 등)

라우팅 알고리즘에 따라 이러한 기준을 조합해 사용하기도 합니다.

## 4. 라우팅은 매우 어려운 문제

슬라이드에서 “top-10 networking challenge”라고 강조한 이유는  
라우팅이 단순히 짧은 길을 찾는 문제가 아니라,

- 네트워크 규모가 매우 크고    
- 링크 상태가 시시각각 변하고
- 트래픽 부하가 계속 변동하고
- 서로 다른 ISP가 각자의 정책을 적용하고

이러한 이유로 **전 세계적으로 라우팅을 설계하고 운영하는 것은 매우 복잡한 문제**이기 때문입니다.

특히 인터넷 백본에서 사용되는 BGP는  
전 세계 네트워크 사업자들이 서로 정책적·경제적 이유로 경로를 선택하기 때문에  
기술적 + 정책적 복잡성이 극도로 높습니다.



# 🔹 번역

**Graph abstraction: link costs**

- ca,bc_{a,b}ca,b​: 라우터 aaa와 bbb를 직접(direct) 연결하는 링크의 비용(cost)  
    예:  
    cw,z=5c_{w,z} = 5cw,z​=5,  
    cu,z=∞c_{u,z} = \inftycu,z​=∞
- 이 비용은 네트워크 운영자가 정의하며, 항상 1로 설정할 수도 있고,  
    **대역폭에 반비례**하거나 **혼잡도에 반비례**하도록 설정할 수도 있음.    
- **그래프 G = (N, E)**
    - NNN: 라우터 집합 = { u, v, w, x, y, z }
    - EEE: 링크 집합 =  
        {(u,v), (u,x), (v,x), (v,w), (x,w), (x,y), (w,y), (w,z), (y,z)}

# 🔹 설명

이 슬라이드는 **라우팅 문제를 그래프(Graph)로 모델링하는 방법**을 설명하고 있습니다.

## 1. 라우터를 그래프의 노드(node)로 표현

라우터는 그래프에서 **정점(vertex)** 으로 나타냄.  
예: 라우터 u, v, w, x, y, z → 그래프 노드 6개.

이렇게 하면 복잡한 네트워크도 수학적으로 단순하게 분석 가능해짐.

## 2. 링크는 그래프의 간선(edge)

두 라우터를 연결하는 **링크(link)** 는  
그래프에서는 **간선(edge)** 으로 표시함.

예: (u, v), (v, w), (w, z) 등.

이 간선에는 **비용(cost)** 이 존재하며, 슬라이드에서는 숫자로 표시됨.

## 3. 링크 비용(link cost)의 의미

링크 비용은 네트워크 운영자가 필요에 따라 설정함.

- 항상 1로 설정  
    → 최소 홉(hop) 라우팅과 같음    
- **대역폭에 반비례**  
    → 대역폭이 넓은 링크의 비용을 낮게 설정  
    → 고속 링크를 더 많이 사용함
- **혼잡도(congestion)에 반비례**  
    → 혼잡한 링크는 비용이 높아짐  
    → 트래픽이 적은 경로로 우회하게 됨

## 4. 비용이 ∞(무한대)라는 의미

예: cu,z=∞c_{u,z} = \inftycu,z​=∞

이는 **u와 z 사이에는 직접 연결된 링크가 없음을 의미**함.

무한대 비용 → 사용 불가능한 링크 → 그래프에서는 “직접 연결 없음”과 같음.

## 5. 왜 그래프로 표현하는가?

라우팅 알고리즘(예: 다익스트라 알고리즘, 벨만-포드)이  
이러한 그래프 모델을 기반으로 최적 경로를 계산하기 때문입니다.

- 노드 = 라우터    
- 간선 = 링크
- 비용 = 링크 품질(거리/속도/혼잡도 등)

이렇게 모델링하면 “최단 경로 문제”로 변환되어  
수학적으로 경로 계산을 수행할 수 있습니다.


# 🔹 번역

**Routing algorithm classification**

- **global:** 모든 라우터가 전체(topology, link cost) 정보를 알고 있음
    - “link state” 알고리즘
- **decentralized:** 이웃 라우터와 정보 교환을 반복하며 경로를 계산하는 방식
    - 라우터는 처음에 자신과 직접 연결된 링크 비용만 알고 있음
    - “distance vector” 알고리즘
- **static:** 경로가 시간에 따라 매우 천천히 변함
- **dynamic:** 경로가 더 빠르게 변함
    - 정기적인 업데이트 또는 링크 비용 변화에 반응하여 업데이트

(좌→우: 경로 변화 속도, 아래→위: 정보 공유 범위: 분산 ↔ 전역)

# 🔹 설명

이 슬라이드는 **라우팅 알고리즘을 분류하는 두 가지 기준**을 설명하고 있다.

## 1. 첫 번째 기준: **정보가 어느 범위까지 공유되는가? (global vs decentralized)**

### ✔ Global routing (전역적 라우팅)

- 네트워크 전체의 링크 구조(topology)와 비용 정보를 모든 라우터가 알고 있음.    
- 중앙 집권적인 방식.
- 대표 알고리즘: **Link State(LS)**  
    → OSPF 같은 프로토콜이 여기에 해당함.

➡ 특징

- 모든 라우터가 전체 그림을 알고 있으므로  
    **최단 경로 계산 정확도가 높고 수렴 속도가 빠름.**

### ✔ Decentralized routing (분산 라우팅)

- 이웃 라우터끼리만 정보를 주고받으며 경로를 계산.    
- 네트워크 전체 정보를 한 번에 알지 못함.
- 대표 알고리즘: **Distance Vector(DV)**  
    → RIP 프로토콜 등이 여기에 해당함.

➡ 특징

- 계산 과정이 반복적(iterative)이고
- 이웃의 정보만 보고 경로를 결정하므로  
    **오류 전파나 수렴 지연 가능성이 있음.**

## 2. 두 번째 기준: **경로가 얼마나 빨리 바뀌는가? (static vs dynamic)**

### ✔ Static routing (정적 라우팅)

- 경로가 거의 변하지 않음    
- 사람이 수동으로 설정하거나 매우 드물게 업데이트됨
- 변화가 적은 환경에서 사용됨 (예: 작은 기업 네트워크)

### ✔ Dynamic routing (동적 라우팅)

- 네트워크 상태 변화(링크 장애, 혼잡 등)에 따라  
    **빠르게 경로를 재계산**하는 방식    
- 주기적인 업데이트 또는 이벤트 기반 업데이트 수행
- 대부분의 현대 네트워크에서 사용됨

## 🔹 전체 그림 정리(설명용)

좌우 축, 상하 축을 조합하면 아래와 같은 분류가 생긴다.

| 분류                          | 의미                                   |
| --------------------------- | ------------------------------------ |
| **Global + Dynamic**        | 전체 정보를 빠르게 공유하며 경로를 빠르게 조정 (예: OSPF) |
| **Global + Static**         | 전체 구조는 알지만 경로는 자주 바꾸지 않음             |
| **Decentralized + Dynamic** | 이웃 정보 기반으로 빠르게 갱신 (예: RIP)           |
| **Decentralized + Static**  | 이웃 정보 기반이지만 거의 변하지 않음                |


# 🔹 **번역**

## **Dijkstra’s link-state routing algorithm**

- **centralized:** 네트워크 토폴로지와 링크 비용이 모든 노드에 알려져 있음
    - “링크 상태 브로드캐스트(link state broadcast)”를 통해 이루어짐
    - 모든 노드는 동일한 정보를 가짐
- **computes least cost paths:** 한 노드(“source”)로부터 다른 모든 노드까지
    - 이 계산 결과는 해당 노드의 **forwarding table(포워딩 테이블)**을 만듦
- **iterative:**  
    k번 반복(iteration) 후에는 **k개의 목적지까지의 최단 비용 경로**가 확정됨

# 🔹 **notation(표기법)**

- **cₓᵧ:**  
    노드 x와 y 사이의 **직접 링크 비용**  
    (직접 연결되지 않았다면 비용은 ∞ 로 둔다)    
- **D(v):**  
    출발 노드에서 목적지 v까지의 **현재 추정된 최소 비용**
- **p(v):**  
    출발지에서 v까지 가는 “경로 상 바로 이전 노드”  
    (즉, v의 predecessor)
- **N′:**  
    **최단 경로가 확정된 노드들의 집합**  
    (이미 정확한 최소 비용을 아는 노드 집합)

# 🔹 **설명**

이 슬라이드는 **링크 상태(Link State) 기반 라우팅**에서 핵심 알고리즘인 **다익스트라(Dijkstra) 알고리즘**의 개념을 설명하고 있다.

## ✔ 왜 “centralized”인가?

링크 상태 라우팅은  
각 노드가 **네트워크 전체 구조**와 **모든 링크 비용**을 정확히 알고 있어야 한다.

- 각 라우터는 자신과 연결된 링크 정보를 브로드캐스트로 네트워크 전체에 전달    
- 모든 라우터가 동일한 “전역 지도”를 갖게 됨
- 결국 각 라우터는 **독립적으로** 다익스트라 알고리즘을 수행하여  
    자신만의 최단 경로 트리를 만든다.

즉, 분산 네트워크이지만 **정보는 전역적으로 공유되는 구조**이므로 “centralized”라고 표현한다.

## ✔ 다익스트라의 핵심 개념들

### 1) **N′ (확정 집합)**

- 이미 최단 경로가 확정된 노드들의 집합    
- 반복(iteration)마다 이 집합이 하나씩 커짐

### 2) **D(v) (거리 추정값)**

- 아직 확정되지 않은 노드들에 대해  
    현재까지 알고 있는 “가장 좋은 경로 비용”

### 3) **p(v)**

- D(v)를 제공해 준 경로에서  
    v 이전 노드를 기록해 두는 것
- 나중에 최단 경로를 역추적하기 위해 필요

## ✔ 왜 iterative인가?

다익스트라는 한 번에 전체를 계산하지 않는다.

- 첫 반복에서는 출발지와 가장 가까운 노드 하나만 확정    
- 다음 반복에서는 두 번째로 가까운 노드를 확정
- 이런 방식으로 **한 번의 반복 = 한 노드의 최단 경로 확정**

그래서 k번 반복하면 최소 k개의 목적지에 대한 최단 경로를 알 수 있다.


# 🔹 **번역**

## **Dijkstra’s algorithm: discussion**

### **algorithm complexity:** n개의 노드

- n번의 반복(iteration) 동안,  
    각 반복마다 **N 집합에 포함되지 않은 모든 노드 w**를 검사해야 함
- 전체 비교 횟수 = n(n+1)/2 → **O(n²)**
- 더 효율적인 구현(예: 힙 사용)도 가능하며, 이 경우 **O(n log n)**

### **message complexity:**

- 각 라우터는 자신의 링크 상태 정보를 **다른 n개의 라우터에게 브로드캐스트**해야 함    
- 효율적인(또는 흥미로운) 브로드캐스트 알고리즘은  
    하나의 노드로부터의 브로드캐스트 메시지를 모든 노드에 전달하는 데  
    **O(n)** 개의 링크 통과(link crossings)을 필요로 함
- 각 라우터의 메시지는 **O(n)** 개의 링크를 통과하므로  
    전체 메시지 복잡도는 **O(n²)**

