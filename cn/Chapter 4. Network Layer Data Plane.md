
## 📌 Network-layer services and protocols (네트워크 계층 서비스 및 프로토콜)

### 1. 송신 호스트에서 수신 호스트로 세그먼트 전달

- **송신자(sender)**  
    전송 계층에서 만들어진 세그먼트를 **데이터그램(datagram)** 형태로 캡슐화한 뒤 **링크 계층으로 전달**합니다.

- **수신자(receiver)**  
    링크 계층으로부터 수신한 데이터그램에서 세그먼트를 **추출하여 전송 계층 프로토콜에 전달**합니다.    

### 2. 네트워크 계층 프로토콜의 적용 범위

- 네트워크 계층은 **모든 인터넷 장치(every Internet device)** 에 존재합니다.  
    예시: **호스트(host), 라우터(router)**

### 3. 라우터의 역할

- **수신한 모든 IP 데이터그램의 헤더 필드를 검사**합니다.
- **입력 포트에서 받은 데이터그램을 적절한 출력 포트로 전달**하여  
    **종단 간(end-to-end) 경로를 따라 데이터그램이 이동하도록 함**.

## 📌 그림 설명 (간단 해설)

- 모바일 네트워크, 기업 네트워크, 데이터센터 네트워크, 글로벌 ISP 등이 **연결되어 하나의 인터넷 경로를 구성**하고 있습니다.
- 각 라우터는 **network / link / physical 계층**으로 구성되어 있으며  
    패킷을 전달할 때 **상위 계층의 데이터를 해석하지 않고 IP 헤더만 기반으로 전달 결정**을 수행합니다.
- **호스트는 application / transport / network / link / physical 계층을 모두 사용**합니다.

## 💡 핵심 요약

| 구성 요소      | 역할                                |
| ---------- | --------------------------------- |
| Sender     | 세그먼트를 데이터그램으로 캡슐화 후 링크 계층으로 전달    |
| Receiver   | 데이터그램에서 세그먼트를 추출해 전송 계층으로 전달      |
| Router     | IP 헤더 검사, 입력 포트 → 출력 포트로 데이터그램 전달 |
| Network 계층 | 모든 인터넷 장치에 존재하며 IP 기반 전달 수행       |

## ✔ 보충 설명

- 네트워크 계층의 대표 프로토콜은 **IP(Internet Protocol)** 입니다.    
- 라우터는 **IP 주소 기반으로 경로를 결정(route)** 하며, **종단 간 신뢰성 보장은 하지 않습니다**.  
    신뢰성은 전송 계층(TCP 등)이 담당합니다.
- 데이터그램 전달의 목표는 **최선형(best-effort)** 전달이며,  
    **지연·손실이 발생하더라도 재전송을 보장하지 않습니다**.



## 📌 Two key network-layer functions (네트워크 계층의 두 핵심 기능)

### 1) Forwarding (포워딩)

- 라우터의 **입력 링크로 들어온 패킷을 적절한 출력 링크로 이동시키는 과정**입니다.
- 즉, **패킷을 다음 라우터 또는 목적지로 넘기는 동작 자체**를 의미합니다.

### 2) Routing (라우팅)

- 패킷이 **출발지에서 목적지까지 도달하기 위한 전체 경로를 결정하는 과정**입니다.
- **라우팅 알고리즘(routing algorithms)** 을 사용하여 최적 경로를 계산합니다.    

## 🔍 둘의 차이를 이해하는 비유 (여행에 비교)

|개념|여행에 비유|설명|
|---|---|---|
|Forwarding|교차로(인터체인지)에서 길을 선택해 빠져나오는 과정|이미 계획된 경로에 따라 다음 구간으로 이동하는 수행 단계|
|Routing|출발지부터 목적지까지 갈 전체 경로를 사전에 계획하는 과정|어떤 경로로 갈지 결정하는 계획 단계|

## ✔ 핵심 요약

|항목|수행 시점|담당 주체|주요 작동 방식|
|---|---|---|---|
|Forwarding|실시간 패킷 전달 중|라우터|포워딩 테이블을 기반으로 다음 출력 포트 선택|
|Routing|경로 계산 단계|각각의 라우터 + 네트워크 전체|라우팅 알고리즘을 통해 경로 계산 후 라우팅 테이블 구성|


## 💡 추가 설명

- Forwarding과 Routing은 함께 동작하지만 **책임 범위가 다릅니다**.  
    Forwarding은 **“지금 이 패킷을 어디로 보낼까?”**,  
    Routing은 **“전체적으로 어떤 경로가 가장 최적·가장 빠르게 목적지에 도달할까?”** 를 결정합니다.
- Routing의 결과가 **라우팅 테이블을 생성하고 유지**, Forwarding은 **라우팅 테이블을 실제 패킷 전달에 사용**합니다.


## 📌 Network layer: data plane, control plane (네트워크 계층: 데이터 플레인, 컨트롤 플레인)

### 🔹 Data Plane (데이터 플레인)

- **로컬(local), 라우터별 기능**
- 라우터의 **입력 포트로 들어온 데이터그램을 어떤 출력 포트로 전달할지 결정하는 역할**
- 즉, **포워딩(forwarding)** 기능을 수행하는 영역입니다.

> 도착한 패킷 헤더의 값을 기반으로 → 포워딩 테이블을 조회 → 특정 출력 포트로 패킷을 전송

### 🔹 Control Plane (컨트롤 플레인)

- **네트워크 전체 관점(network-wide logic)**    
- 데이터그램이 **출발지에서 목적지까지 네트워크 내 여러 라우터를 어떤 경로로 통과할지 결정**
- 즉, **라우팅(routing)** 기능을 수행하는 영역입니다.

#### 컨트롤 플레인의 두 가지 방식

| 방식                  | 설명                   | 구현 위치     |
| ------------------- | -------------------- | --------- |
| 전통적 라우팅 알고리즘        | 각 라우터가 스스로 라우팅 계산 수행 | 라우터 내부    |
| 소프트웨어 정의 네트워킹 (SDN) | 컨트롤 기능을 서버에 중앙집중화    | 외부(원격) 서버 |

## ✔ 핵심 비교 요약

| 항목    | Data Plane            | Control Plane            |
| ----- | --------------------- | ------------------------ |
| 기능    | 패킷 전달 (포워딩)           | 경로 결정 (라우팅)              |
| 적용 범위 | 개별 라우터 로컬             | 네트워크 전체                  |
| 작동 방식 | 포워딩 테이블 기반으로 출력 포트 선택 | 라우팅 알고리즘 또는 SDN 기반 경로 계산 |
| 시간 특성 | 실시간                   | 비실시간 (계산 후 테이블에 반영)      |

## 💡 추가 설명

- Control Plane이 **라우팅 테이블을 생성·관리**하고, Data Plane은 그 테이블을 기반으로 **실제로 패킷을 전달**합니다.    
- SDN 방식에서는 **제어 기능이 분리되어 중앙 컨트롤러가 경로를 결정**하고, 라우터는 **데이터 전달에만 집중**합니다.
- 이 분리는 대규모 네트워크에서 **트래픽 관리 효율성, 정책 적용, 네트워크 확장성**을 향상시킵니다.


## 📌 Per-router control plane (라우터별 컨트롤 플레인)

### 🔹 개념 설명

- **각 라우터 내부에 라우팅 알고리즘이 존재하며**,  
    이 라우팅 알고리즘들이 서로 **정보를 교환하며 컨트롤 플레인을 구성**합니다.
- 즉, **네트워크 전체 경로를 계산하는 작업을 각 라우터가 분산적으로 수행**하는 방식입니다.

### 🔹 동작 과정 이해

1. 각 라우터는 **라우팅 알고리즘을 실행**합니다.    
2. 라우터끼리는 **라우팅 정보를 서로 교환**합니다. (그림의 빨간 화살표)
3. 이 정보 교환을 통해 **라우팅 테이블이 업데이트**됩니다.
4. 업데이트된 테이블이 **데이터 플레인에 반영**되어 포워딩이 수행됩니다.

### 🔹 구조적 분리

| 영역            | 역할                     | 위치         |
| ------------- | ---------------------- | ---------- |
| Control Plane | 라우팅 계산 및 테이블 생성        | 라우터 내부(상단) |
| Data Plane    | 라우팅 테이블을 바탕으로 실제 패킷 전달 | 라우터 내부(하단) |

### 🔹 그림의 핵심 포인트 요약

- **좌측 패킷 예시**  
    패킷의 헤더 값이 입력되면 → **로컬 포워딩 테이블 조회 → 출력 포트 선택**    
- **각 라우터 상단의 빨간 연결선**  
    라우터들 간 **라우팅 정보 교환 → 컨트롤 플레인 형성**
- **각 라우터 하단의 파란 부분**  
    실제 패킷 전달이 이루어지는 **데이터 플레인**

## ✔ 핵심 요약

| 특징        | Per-router control plane        |
| --------- | ------------------------------- |
| 라우팅 계산 방식 | 라우터 개별적으로 수행 (분산형)              |
| 장점        | 장애 시에도 일부 라우터는 계속 동작 가능, 분산적 확장 |
| 단점        | 관리 어려움, 라우팅 계산 복잡 및 비효율 가능      |
| 대표 기술     | RIP, OSPF, BGP 등 기존 라우팅 프로토콜    |


## 📌 Software-Defined Networking (SDN) control plane

**SDN 컨트롤 플레인**

### 🔹 핵심 개념

- **컨트롤 플레인 기능을 라우터 내부가 아닌 외부(원격) 컨트롤러에 집중시키는 방식**입니다.
- 원격 컨트롤러가 **라우팅 계산을 수행하고**, 그 결과를 라우터에 전달하여 **포워딩 테이블을 설치**합니다.

### 🔹 동작 과정 요약

1. 네트워크 전체의 상태를 SDN 컨트롤러가 수집합니다.    
2. 컨트롤러가 **패킷 경로(라우팅)** 를 통합적으로 계산합니다.
3. 계산된 결과를 각 라우터에 전달하여 **포워딩 테이블을 구성/업데이트**합니다.
4. 라우터는 전달받은 포워딩 테이블을 사용하여 **데이터 플레인에서 실시간 패킷 전달**을 수행합니다.

> 즉, **라우팅 결정은 중앙 서버가 담당하고**, **라우터는 전달(Forwarding) 기능에만 집중합니다.**

### 🔹 구조적 분리

| 영역            | 역할               | 위치              |
| ------------- | ---------------- | --------------- |
| Control Plane | 라우팅 계산 및 정책 적용   | SDN 원격 컨트롤러(중앙) |
| Data Plane    | 포워딩 테이블 기반 패킷 전달 | 개별 라우터 내부       |


### 🔹 그림 이해 포인트

- 상단의 **Remote Controller**  
    → 네트워크 전체 경로를 계획하여 포워딩 테이블을 생성    
- 하단의 **라우터들 (CA 표기)**  
    → 컨트롤러가 내려주는 테이블을 수신하고 데이터 전달만 수행
- 빨간 화살표  
    → 컨트롤러 ↔ 라우터 간 포워딩 규칙 전달

## ✔ SDN의 장점

| 항목        | 설명                             |
| --------- | ------------------------------ |
| 중앙 집중 관리  | 네트워크 전체 정책 및 경로를 컨트롤러에서 일괄 제어  |
| 유연성 및 확장성 | 소프트웨어 업데이트만으로 네트워크 동작 변경 가능    |
| 자동화       | 트래픽 상황에 따라 실시간 라우팅 정책 자동 조정 가능 |

## ✔ SDN의 단점

| 항목           | 설명                                   |
| ------------ | ------------------------------------ |
| 컨트롤러 장애 시 위험 | 단일 장애 지점(Single Point of Failure) 가능 |
| 높은 초기 구축 비용  | 컨트롤러 인프라 구축 및 장비 호환 필요               |

## 💡 Per-router Control Plane과의 비교

| 방식           | Per-router control plane | SDN control plane            |
| ------------ | ------------------------ | ---------------------------- |
| 구조           | 분산형                      | 중앙집중형                        |
| 라우팅 계산 수행 주체 | 각 라우터                    | SDN 컨트롤러                     |
| 라우터의 역할      | 경로 계산 + 전달               | 전달(Forwarding) 전담            |
| 대표 프로토콜/기술   | RIP, OSPF, BGP           | OpenFlow, ONOS, OpenDaylight |


## 📌 Network service model (네트워크 서비스 모델)

### 🔹 핵심 질문

> 송신자에서 수신자로 데이터그램을 운반하는 **채널이 제공할 수 있는 서비스 모델은 무엇인가?**

네트워크 계층은 모든 데이터그램을 그냥 “최선형 전달(best-effort)”로 보내는 것만이 아니라, 특정 서비스 품질(QoS)을 제공하도록 설계될 수도 있습니다.

## 🔸 서비스 모델의 예시

### 1) 개별 데이터그램을 위한 서비스 (individual datagrams)

|서비스 예시|설명|
|---|---|
|guaranteed delivery|데이터그램의 **전달을 보장**|
|guaranteed delivery with less than 40 ms delay|**40ms 이하의 지연을 보장하면서 전달**|

→ 단일 패킷의 도착 여부 및 지연 시간에 초점을 둔 서비스

### 2) 데이터그램 흐름(flow) 전체를 위한 서비스

한 세션 또는 스트림 단위의 패킷 흐름(flow)에 대해 적용되는 서비스

|서비스 예시|설명|
|---|---|
|in-order datagram delivery|패킷을 **전송한 순서대로 도착하도록 보장**|
|guaranteed minimum bandwidth to flow|해당 흐름을 위해 **최소 대역폭을 보장**|
|restrictions on changes in inter-packet spacing|**패킷 간 시간 간격(inter-packet spacing)의 변화를 제한**하여 지터(jitter) 억제|

→ 실시간 스트리밍, 화상회의, 온라인 게임 등 연속적인 패킷 품질이 중요한 서비스에서 필요

## 💡 정리 요약

|서비스 범위|초점|예시|
|---|---|---|
|개별 데이터그램|하나의 패킷의 안전성과 지연|guaranteed delivery, low-delay delivery|
|데이터그램 흐름|스트림 전체의 품질과 일관성|in-order delivery, bandwidth guarantee, jitter control|


## 📌 Network-layer service model (네트워크 계층 서비스 모델)

### 🔹 현재 인터넷의 네트워크 서비스 모델

|Network Architecture|Service Model|QoS 보장 항목|
|---|---|---|
|Internet|best effort|Bandwidth: none / Loss: no / Order: no / Timing: no|

인터넷은 **best effort** 방식을 사용하며, 이는 **전송 품질을 보장하지 않는 모델**을 의미합니다.

### 🔹 Best-effort 서비스 모델의 특징

**보장하지 않는 항목**

1. **데이터그램이 목적지까지 성공적으로 전달된다는 보장 없음**
2. **도착 시간(timing) 또는 순서(order)에 대한 보장 없음**
3. **종단 간(end-to-end) 흐름에 대해 사용 가능한 대역폭 보장 없음**

즉, 네트워크 계층은 패킷을 “가능한 한 전달해 보려는 노력”만 수행하며,  
**지연, 손실, 재전송, 순서 유지, 대역폭 확보 등에 대한 책임을 지지 않습니다.**

### 💡 추가 설명

- TCP, UDP 등의 전송 계층이 **신뢰성 보완 역할을 담당하는 이유**가 바로 이 best-effort 모델 때문입니다.
    - TCP는 손실 복구, 순서 재정렬, 흐름 제어 등을 제공
    - UDP는 보장을 하지 않고 지연을 최소화하는 방향 선택

- 네트워크 계층 자체는 **QoS 지원이 없지만**, 멀티미디어·스트리밍 시대 이후  
    **DiffServ, IntServ, MPLS 등 QoS 기술이 별도로 연구 및 적용**되고 있습니다.    

### ✔ 핵심 요약

|항목|Best-effort 네트워크의 동작 방식|
|---|---|
|패킷 손실|허용됨 (보장하지 않음)|
|전달 순서|보장하지 않음|
|지연 시간|보장하지 않음|
|대역폭|보장하지 않음|
|역할|가능한 한 전달하려고 시도함|


## 📌 Reflections on best-effort service (베스트 에포트 서비스에 대한 고찰)

### 🔹 Best-effort 모델이 성공한 이유

- **메커니즘의 단순성(simplicity of mechanism)**  
    인터넷이 전 세계적으로 빠르게 확산되고 채택될 수 있었던 핵심 요인입니다.  
    설계가 단순하여 확장성·구현 용이성이 매우 뛰어납니다.

- **충분한 대역폭 확보(provisioning of bandwidth)**  
    네트워크 인프라가 발전하면서  
    음성·영상 등 실시간 애플리케이션도 대부분의 시간 동안 충분히 “잘 동작”할 수 있게 되었습니다.
   
- **애플리케이션 계층의 분산 서비스 구조(replication, application-layer distributed services)**  
    데이터센터와 CDN(Content Distribution Network)을  
    사용자 근처에 배치함으로써 가져올 수 있는 성능 향상 덕분에  
    네트워크 계층 QoS 보장이 없어도 서비스 품질을 높일 수 있었습니다.
 
- **탄력적(elastic) 서비스의 혼잡 제어(congestion control)**  
    TCP 기반 서비스와 같은 탄력적 애플리케이션이 혼잡 제어를 수행함으로써  
    네트워크의 과부하 및 붕괴를 방지하고 신뢰성을 높였습니다.
   

### 🔻 결론 문장

> **“best-effort 서비스 모델의 성공을 부정하기는 어렵다.”**  
> → QoS 보장을 제공하지 않지만, 단순성과 확장성, 애플리케이션 계층 기술의 발전으로 인해  
> 인터넷은 오늘날까지도 best-effort 기반으로 안정적으로 유지되고 있습니다.

## 💡 추가 요약 (시험 대비)

| 항목            | 요점                             |
| ------------- | ------------------------------ |
| 핵심 장점         | 단순성, 확장성, 빠른 보급                |
| 어떻게 품질을 보완했는가 | 대역폭 확충, CDN/데이터센터 분산, TCP 혼잡제어 |
| 핵심 메시지        | QoS 없이도 충분히 성공적이었음             |



## 📌 Router architecture overview (라우터 아키텍처 개요)

### 🔹 라우터의 고수준 구조

라우터는 크게 다음 세 부분으로 구성됩니다.

|구성 요소|역할|
|---|---|
|입력 포트 (router input ports)|데이터그램 수신, 헤더 검사, 포워딩 테이블 조회 준비|
|스위칭 패브릭 (high-speed switching fabric)|입력 포트에서 출력 포트로 패킷을 고속으로 전달|
|출력 포트 (router output ports)|큐잉, 스케줄링, 패킷 전송|

### 🔹 Control Plane vs Data Plane

|Plane|역할|위치|동작 속도|
|---|---|---|---|
|Control Plane|라우팅 및 관리 소프트웨어 실행|Routing Processor|밀리초(ms) 시간 단위|
|Data Plane|실제 패킷 포워딩 수행|입·출력 포트 하드웨어|나노초(ns) 시간 단위|

### ✔ Routing Processor (라우팅 프로세서)

- 라우팅 알고리즘, 라우팅 테이블 유지·관리, 네트워크 관리 기능 수행
- 새로운 경로가 학습되면 포워딩 테이블을 업데이트하여 데이터 플레인에 반영

### ✔ High-speed Switching Fabric (고속 스위칭 패브릭)

- 입력 포트에서 출력 포트로 **패킷을 고속으로 연결해 전달**
- 라우터 성능을 좌우하는 핵심 하드웨어


### 🔍 구조를 한 줄로 이해하면

> Control Plane이 **경로를 결정하고**, Data Plane이 **그 경로에 따라 매우 빠르게 패킷을 전달**함

## 핵심 요약

|항목|요점|
|---|---|
|Control Plane|라우팅 계산 및 관리 수행, 느리지만 두뇌 역할|
|Data Plane|패킷 포워딩 처리, 매우 빠른 하드웨어 동작|
|스위칭 패브릭|입력 포트 → 출력 포트 연결|
|시간 단위|Control Plane: ms / Data Plane: ns|

## 📌 Input port functions (입력 포트 기능)

### 🔹 입력 포트 내부 구성 요소

입력 포트는 스위칭 패브릭으로 패킷을 전달하기 전에 다음 단계를 수행합니다.

|단계|설명|관련 계층|
|---|---|---|
|line termination|비트 단위로 신호 수신|물리 계층 (physical layer)|
|link layer protocol (receive)|링크 계층 프레임 처리 (예: Ethernet)|링크 계층 (link layer)|
|lookup, forwarding, queueing|헤더 기반 출력 포트 조회, 큐에 적재 후 전송|네트워크 계층 데이터 플레인|


### 🔹 Decentralized switching (분산 스위칭)

- 입력 포트가 **포워딩 테이블을 자체적으로 보유**하고 있어  
    **헤더 값 기반으로 적절한 출력 포트를 즉시 조회**합니다.
- 즉, **각 입력 포트가 독립적으로 lookup + action 수행**합니다.
- 이 설계의 목적은:
    > 입력 포트에서의 처리 속도를 **line speed(회선 속도)** 에 맞출 수 있도록 하기 위함입니다.

### 🔹 Input port queueing (입력 포트 큐잉)

- 데이터그램 도착 속도가 스위칭 패브릭의 처리 속도보다 빠를 경우  
    입력 포트 내부 큐에 패킷을 저장합니다.    
- 큐가 과도하게 증가할 경우 **패킷 지연 또는 드롭**이 발생할 수 있습니다.

## ✔ 핵심 요약

| 핵심 개념    | 설명                                        |
| -------- | ----------------------------------------- |
| 입력 포트 역할 | 패킷을 수신, 링크 계층 처리, 헤더 기반 출력 포트 조회, 큐잉 수행   |
| 분산 스위칭   | 입력 포트가 자체적으로 lookup 수행 (“match + action”) |
| 목표       | 전체 처리 속도를 line speed로 유지                  |
| 큐잉 이유    | 패킷 도착 속도가 스위칭 패브릭 처리 속도를 초과할 때            |

### 🔹 Destination-based forwarding (목적지 기반 포워딩)

- **목적지 IP 주소만**을 이용하여 포워딩 결정을 수행하는 방식입니다.
- 현재 인터넷에서 사용되는 **전통적·표준적인 포워딩 방식**입니다.
### 🔹 Generalized forwarding (일반화된 포워딩)

- **헤더의 다양한 필드 값 조합**을 기반으로 포워딩 결정을 수행하는 방식입니다.

