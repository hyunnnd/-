
# Application Layer: Overview

## 목표

- 애플리케이션 계층 프로토콜의 개념적 **및** 구현적 측면 학습
    - 전송 계층 서비스 모델
    - 클라이언트-서버 패러다임
    - 피어-투-피어 패러다임
- 널리 사용되는 애플리케이션 계층 프로토콜을 통해 학습
    - HTTP
    - SMTP, IMAP
    - DNS

# Creating a Network App (네트워크 앱 만들기)

## 작성해야 하는 프로그램

- (서로 다른) 종단 시스템(end systems)에서 실행
- 네트워크를 통해 통신
- 예: 웹 서버 소프트웨어가 브라우저 소프트웨어와 통신

## 작성할 필요 없는 부분

- 네트워크 코어 장치(network-core devices)를 위한 소프트웨어는 작성할 필요 없음
    - 네트워크 코어 장치는 사용자 애플리케이션을 실행하지 않음
    - 애플리케이션은 종단 시스템(end systems)에서 실행됨
    - 이를 통해 빠른 애플리케이션 개발 및 배포 가능

📌 요약: **네트워크 애플리케이션은 종단 시스템에서 실행되며, 네트워크 코어 장치에는 직접 작성할 필요가 없다.**


# Client-Server Paradigm (클라이언트-서버 패러다임)

## 서버 (server)

- 항상 켜져 있는 호스트 (always-on host)
- 고정 IP 주소 보유 (permanent IP address)
- 확장성을 위해 데이터 센터에 위치하는 경우 많음
## 클라이언트 (clients)

- 서버와 연결하여 통신
- 간헐적으로 연결될 수 있음
- 동적 IP 주소를 가질 수 있음
- 서로 직접 통신하지 않음
- 예시: **HTTP, IMAP, FTP**

📌 요약: **클라이언트는 서버를 통해 통신하며, 서버는 항상 켜져 있고 고정된 주소를 가진다.**


# Peer-to-Peer Architecture (P2P 아키텍처)

- **항상 켜져 있는 서버 없음 (no always-on server)**
- 임의의 종단 시스템이 직접 통신 가능
- 피어는 다른 피어에게 서비스를 요청하고, 동시에 다른 피어에게 서비스를 제공
    - _자체 확장성 (self scalability)_: 새로운 피어가 참여하면 새로운 서비스 용량과 동시에 새로운 서비스 수요가 함께 추가됨
- 피어는 간헐적으로 연결되며 IP 주소가 바뀔 수 있음
    - 관리가 복잡해짐 (complex management)
- **예시**: P2P 파일 공유, 블록체인

📌 요약: **P2P는 중앙 서버 없이 피어들끼리 직접 통신하고 자율적으로 확장되지만, 관리가 복잡하다.**


# Processes Communicating (프로세스 간 통신)

## 프로세스 (process)

- 호스트 내에서 실행되는 프로그램
## 동일 호스트 내 통신

- 두 프로세스는 **프로세스 간 통신(inter-process communication, IPC)**을 통해 통신
- IPC는 운영체제(OS)에 의해 정의됨
## 다른 호스트 간 통신

- 서로 다른 호스트에 있는 프로세스는 **메시지 교환(messages)**을 통해 통신
## 클라이언트-서버 프로세스

- **클라이언트 프로세스 (client process)**: 통신을 시작하는 프로세스
- **서버 프로세스 (server process)**: 접속을 기다리는 프로세스
## 참고

- P2P 아키텍처를 사용하는 애플리케이션도 클라이언트 프로세스와 서버 프로세스를 모두 가짐

📌 요약: **프로세스는 같은 호스트에서는 IPC로, 다른 호스트에서는 메시지 교환으로 통신한다. P2P 구조도 결국 클라이언트·서버 프로세스로 동작한다.**


# Sockets (소켓)

## 정의

- 프로세스는 소켓을 통해 메시지를 송수신함
## 소켓의 비유

- 소켓은 **문(door)**과 유사
    - 송신 프로세스는 메시지를 문 밖으로 내보냄
    - 송신 프로세스는 문 건너편의 **전송 계층 인프라**에 의존하여 수신 프로세스의 소켓까지 메시지를 전달
- 두 개의 소켓이 필요 (각각 송신 측과 수신 측)
## 제어 권한

- **애플리케이션 개발자**: 애플리케이션 계층에서 소켓 제어
- **운영체제(OS)**: 전송, 네트워크, 링크, 물리 계층 제어

📌 요약: **소켓은 프로세스가 네트워크를 통해 메시지를 주고받는 출입구 역할을 하며, 애플리케이션 개발자는 소켓을 제어하지만 실제 전달은 OS의 전송 인프라에 의존한다.**


# Addressing Processes (프로세스 주소 지정)

## 메시지 수신을 위한 조건

- 프로세스는 반드시 **식별자(identifier)**를 가져야 함
- 호스트 장치는 고유한 **32비트 IP 주소**를 가짐
## 질문 (Q&A)

- Q: 프로세스가 실행되는 호스트의 IP 주소만으로 해당 프로세스를 식별할 수 있는가?
- A: **아니오.** 하나의 호스트에서 여러 프로세스가 동시에 실행될 수 있음
## 식별자(identifier)

- **IP 주소 + 포트 번호**로 구성됨
- 예시 포트 번호:
    - HTTP 서버: `80`
    - 메일 서버: `25`
## 예시

- 웹 서버 `gaia.cs.umass.edu`로 HTTP 메시지를 보낼 경우:
    - IP 주소: `128.119.245.12`
    - 포트 번호: `80`

📌 요약: **프로세스를 구분하기 위해서는 IP 주소와 포트 번호가 함께 필요하다.**


# An Application-Layer Protocol Defines (애플리케이션 계층 프로토콜이 정의하는 것)

## 프로토콜이 정의하는 요소

- **메시지 유형 (types of messages exchanged)**    
    - 예: 요청(request), 응답(response)

- **메시지 구문 (message syntax)**
    - 메시지에 포함된 필드와 그 구분 방법

- **메시지 의미 (message semantics)**    
    - 각 필드의 정보 의미

- **규칙 (rules)**    
    - 언제, 어떻게 프로세스가 메시지를 보내고 응답하는지

## 프로토콜 유형

- **오픈 프로토콜 (open protocols)**    
    - RFC에 정의되어 있어 누구나 접근 가능
    - 상호 운용성(interoperability) 보장
    - 예: HTTP, SMTP

- **독점 프로토콜 (proprietary protocols)**    
    - 특정 기업/제품 전용
    - 예: Skype


📌 요약: **애플리케이션 계층 프로토콜은 메시지의 형식, 의미, 규칙을 정의하며 오픈 또는 독점 방식으로 나뉜다.**

# What Transport Service Does an App Need?

## Data Integrity (데이터 무결성)

- 일부 앱(예: 파일 전송, 웹 거래)은 **100% 신뢰할 수 있는 데이터 전송** 필요
- 다른 앱(예: 오디오)은 일부 손실을 허용 가능
## Timing (타이밍)

- 일부 앱(예: 인터넷 전화, 인터랙티브 게임)은 **낮은 지연 시간**이 필요
## Throughput (처리량)

- 일부 앱(예: 멀티미디어)은 **최소한의 처리량 보장** 필요
- 다른 앱(“elastic apps”)은 가용한 처리량을 그대로 활용
## Security (보안)

- 암호화, 데이터 무결성 보장 등 필요

📌 요약: **애플리케이션의 특성에 따라 전송 계층이 보장해야 하는 요소(무결성, 지연, 처리량, 보안)가 달라진다.**


![[Pasted image 20250915105132.png]]

# Internet Transport Protocols Services

## TCP Service

- **신뢰성 있는 전송 (reliable transport)**: 송신 프로세스와 수신 프로세스 간 데이터 전송 보장   
- **흐름 제어 (flow control)**: 송신자가 수신자를 압도하지 않도록 조절
- **혼잡 제어 (congestion control)**: 네트워크 과부하 시 송신자 속도 제한
- **제공하지 않는 것**: 타이밍, 최소 처리량 보장, 보안
- **연결 지향적 (connection-oriented)**: 클라이언트와 서버 간 연결 설정 필요
## UDP Service

- **신뢰성 없는 전송 (unreliable data transfer)**: 송신-수신 간 전송 보장 없음
- **제공하지 않는 것**:
    - 신뢰성 (reliability)
    - 흐름 제어 (flow control)
    - 혼잡 제어 (congestion control)
    - 타이밍 (timing)
    - 처리량 보장 (throughput guarantee)
    - 보안 (security)
    - 연결 설정 (connection setup)
## 질문
- Q: 그런데 왜 굳이 UDP가 있는가?

📌 요약:
- **TCP**는 신뢰성과 제어 기능을 제공하지만, 무겁고 연결 설정이 필요함. 
- **UDP**는 단순하고 가볍지만 신뢰성을 제공하지 않음.

![[Pasted image 20250915105313.png]]

# Web and HTTP

## 웹 페이지 구성

- 웹 페이지는 여러 **객체(objects)**로 이루어지며, 각 객체는 서로 다른 웹 서버에 저장될 수 있음    
- 객체(object)의 예시:
    - HTML 파일
    - JPEG 이미지
    - Java 애플릿
    - 오디오 파일 등

## 웹 페이지 구조

- 하나의 웹 페이지는 **기본 HTML 파일(base HTML-file)**로 구성됨
- 기본 HTML 파일은 **여러 참조 객체(referenced objects)**를 포함
- 각 참조 객체는 **URL**을 통해 접근 가능
### URL 예시

`www.someschool.edu/someDept/pic.gif`

- Host name: `www.someschool.edu`
- Path name: `/someDept/pic.gif`

📌 요약: **웹 페이지 = 기본 HTML + 여러 참조 객체(이미지, 오디오 등), 각각은 URL로 식별됨.**


# HTTP Overview

## HTTP: Hypertext Transfer Protocol

- 웹의 **애플리케이션 계층 프로토콜**
- **클라이언트/서버 모델**
    - **Client**:
        - 브라우저(예: Firefox, Safari)
        - HTTP 프로토콜을 사용하여 웹 객체 요청 및 수신
        - 수신한 객체를 화면에 표시
    - **Server**:
        - 웹 서버(예: Apache Web Server)
        - 클라이언트 요청에 따라 HTTP 프로토콜을 사용해 웹 객체를 전송

# HTTP Overview (continued)

## HTTP uses TCP

- 클라이언트가 서버(포트 80)에 **TCP 연결**을 생성 (소켓 생성)    
- 서버는 클라이언트의 TCP 연결을 수락
- 브라우저(HTTP 클라이언트)와 웹 서버(HTTP 서버) 간에 **HTTP 메시지 교환**
- 데이터 교환이 끝나면 TCP 연결 종료

## HTTP is Stateless

- 서버는 과거 클라이언트 요청에 대한 **상태 정보(state)를 저장하지 않음**
- 장점: 단순하고 효율적
- 단점: 상태 정보를 유지하지 않음

### Aside: 상태 유지 프로토콜은 복잡함

- 과거 기록(state)을 관리해야 함
- 서버나 클라이언트가 다운될 경우 상태 정보 불일치 문제가 발생할 수 있음
- 불일치를 조정해야 하는 부담이 있음

📌 요약:
- **HTTP는 TCP 기반, 클라이언트-서버 구조, 상태를 저장하지 않는(stateless) 프로토콜**이다.


