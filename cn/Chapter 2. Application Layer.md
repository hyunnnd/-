
# Application Layer: Overview

## 목표

- 애플리케이션 계층 프로토콜의 개념적 **및** 구현적 측면 학습
    - 전송 계층 서비스 모델
    - 클라이언트-서버 패러다임
    - 피어-투-피어 패러다임
- 널리 사용되는 애플리케이션 계층 프로토콜을 통해 학습
    - HTTP
    - SMTP, IMAP
    - DNS

# Creating a Network App (네트워크 앱 만들기)

## 작성해야 하는 프로그램

- (서로 다른) 종단 시스템(end systems)에서 실행
- 네트워크를 통해 통신
- 예: 웹 서버 소프트웨어가 브라우저 소프트웨어와 통신

## 작성할 필요 없는 부분

- 네트워크 코어 장치(network-core devices)를 위한 소프트웨어는 작성할 필요 없음
    - 네트워크 코어 장치는 사용자 애플리케이션을 실행하지 않음
    - 애플리케이션은 종단 시스템(end systems)에서 실행됨
    - 이를 통해 빠른 애플리케이션 개발 및 배포 가능

📌 요약: **네트워크 애플리케이션은 종단 시스템에서 실행되며, 네트워크 코어 장치에는 직접 작성할 필요가 없다.**


# Client-Server Paradigm (클라이언트-서버 패러다임)

## 서버 (server)

- 항상 켜져 있는 호스트 (always-on host)
- 고정 IP 주소 보유 (permanent IP address)
- 확장성을 위해 데이터 센터에 위치하는 경우 많음
## 클라이언트 (clients)

- 서버와 연결하여 통신
- 간헐적으로 연결될 수 있음
- 동적 IP 주소를 가질 수 있음
- 서로 직접 통신하지 않음
- 예시: **HTTP, IMAP, FTP**

📌 요약: **클라이언트는 서버를 통해 통신하며, 서버는 항상 켜져 있고 고정된 주소를 가진다.**


# Peer-to-Peer Architecture (P2P 아키텍처)

- **항상 켜져 있는 서버 없음 (no always-on server)**
- 임의의 종단 시스템이 직접 통신 가능
- 피어는 다른 피어에게 서비스를 요청하고, 동시에 다른 피어에게 서비스를 제공
    - _자체 확장성 (self scalability)_: 새로운 피어가 참여하면 새로운 서비스 용량과 동시에 새로운 서비스 수요가 함께 추가됨
- 피어는 간헐적으로 연결되며 IP 주소가 바뀔 수 있음
    - 관리가 복잡해짐 (complex management)
- **예시**: P2P 파일 공유, 블록체인

📌 요약: **P2P는 중앙 서버 없이 피어들끼리 직접 통신하고 자율적으로 확장되지만, 관리가 복잡하다.**


# Processes Communicating (프로세스 간 통신)

## 프로세스 (process)

- 호스트 내에서 실행되는 프로그램
## 동일 호스트 내 통신

- 두 프로세스는 **프로세스 간 통신(inter-process communication, IPC)**을 통해 통신
- IPC는 운영체제(OS)에 의해 정의됨
## 다른 호스트 간 통신

- 서로 다른 호스트에 있는 프로세스는 **메시지 교환(messages)**을 통해 통신
## 클라이언트-서버 프로세스

- **클라이언트 프로세스 (client process)**: 통신을 시작하는 프로세스
- **서버 프로세스 (server process)**: 접속을 기다리는 프로세스
## 참고

- P2P 아키텍처를 사용하는 애플리케이션도 클라이언트 프로세스와 서버 프로세스를 모두 가짐

📌 요약: **프로세스는 같은 호스트에서는 IPC로, 다른 호스트에서는 메시지 교환으로 통신한다. P2P 구조도 결국 클라이언트·서버 프로세스로 동작한다.**


# Sockets (소켓)

## 정의

- 프로세스는 소켓을 통해 메시지를 송수신함
## 소켓의 비유

- 소켓은 **문(door)**과 유사
    - 송신 프로세스는 메시지를 문 밖으로 내보냄
    - 송신 프로세스는 문 건너편의 **전송 계층 인프라**에 의존하여 수신 프로세스의 소켓까지 메시지를 전달
- 두 개의 소켓이 필요 (각각 송신 측과 수신 측)
## 제어 권한

- **애플리케이션 개발자**: 애플리케이션 계층에서 소켓 제어
- **운영체제(OS)**: 전송, 네트워크, 링크, 물리 계층 제어

📌 요약: **소켓은 프로세스가 네트워크를 통해 메시지를 주고받는 출입구 역할을 하며, 애플리케이션 개발자는 소켓을 제어하지만 실제 전달은 OS의 전송 인프라에 의존한다.**


# Addressing Processes (프로세스 주소 지정)

## 메시지 수신을 위한 조건

- 프로세스는 반드시 **식별자(identifier)**를 가져야 함
- 호스트 장치는 고유한 **32비트 IP 주소**를 가짐
## 질문 (Q&A)

- Q: 프로세스가 실행되는 호스트의 IP 주소만으로 해당 프로세스를 식별할 수 있는가?
- A: **아니오.** 하나의 호스트에서 여러 프로세스가 동시에 실행될 수 있음
## 식별자(identifier)

- **IP 주소 + 포트 번호**로 구성됨
- 예시 포트 번호:
    - HTTP 서버: `80`
    - 메일 서버: `25`
## 예시

- 웹 서버 `gaia.cs.umass.edu`로 HTTP 메시지를 보낼 경우:
    - IP 주소: `128.119.245.12`
    - 포트 번호: `80`

📌 요약: **프로세스를 구분하기 위해서는 IP 주소와 포트 번호가 함께 필요하다.**


# An Application-Layer Protocol Defines (애플리케이션 계층 프로토콜이 정의하는 것)

## 프로토콜이 정의하는 요소

- **메시지 유형 (types of messages exchanged)**    
    - 예: 요청(request), 응답(response)

- **메시지 구문 (message syntax)**
    - 메시지에 포함된 필드와 그 구분 방법

- **메시지 의미 (message semantics)**    
    - 각 필드의 정보 의미

- **규칙 (rules)**    
    - 언제, 어떻게 프로세스가 메시지를 보내고 응답하는지

## 프로토콜 유형

- **오픈 프로토콜 (open protocols)**    
    - RFC에 정의되어 있어 누구나 접근 가능
    - 상호 운용성(interoperability) 보장
    - 예: HTTP, SMTP

- **독점 프로토콜 (proprietary protocols)**    
    - 특정 기업/제품 전용
    - 예: Skype


📌 요약: **애플리케이션 계층 프로토콜은 메시지의 형식, 의미, 규칙을 정의하며 오픈 또는 독점 방식으로 나뉜다.**

