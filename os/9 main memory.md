## Swapping

**Swapping**은 프로세스를 메모리에서 임시로 백업 저장소(backing store)로 옮겼다가, 나중에 다시 메모리로 가져와 실행을 계속할 수 있도록 하는 기법임.

- 전체 프로세스의 물리적 메모리 요구량이 실제 물리 메모리 용량을 초과할 수 있도록 해 줌
- **백업 저장소(backing store)**: 모든 사용자에 대한 메모리 이미지를 저장할 수 있을 만큼 충분히 큰 고속 디스크임. 운영체제는 여기에 직접 접근 가능해야 함
- 시스템은 디스크에 메모리 이미지를 갖고 있는 준비 상태의 프로세스들을 위한 ready queue를 유지함

### 그림 설명

- 운영체제는 메인 메모리 상단에 상주
- 사용자 공간에는 현재 실행 중인 프로세스가 존재
- `swap out`: 프로세스 P₁을 메인 메모리에서 백업 저장소로 이동
- `swap in`: 저장소에 있던 프로세스 P₂를 메인 메모리로 불러와 실행


## Context Switch Time including Swapping

- CPU에 올릴 다음 프로세스가 메모리에 없을 경우, 현재 프로세스를 `swap out` 하고 대상 프로세스를 `swap in` 해야 함
- 이로 인해 **문맥 교환 시간(context switch time)** 이 매우 커질 수 있음

### 스왑 시간의 대부분은 **전송 시간(transfer time)** 이 차지
- 전송 시간은 스왑되는 메모리 크기에 **비례함**

### 예시
- 프로세스 크기: 100MB  
- 디스크 전송 속도: 50MB/sec  
- 스왑 아웃 시간 = 100MB / 50MB/s = 2초 = 2000ms  
- 스왑 인 시간 = 100MB / 50MB/s = 2초 = 2000ms  
- **총 문맥 교환 시간 = 2000ms + 2000ms = 4000ms (4초)**

> 스왑을 포함한 문맥 교환은 디스크 I/O 속도에 따라 매우 느려질 수 있으며, 이는 시스템 반응성과 성능에 큰 영향을 미침


## Context Switch Time and Swapping

### 표준 스와핑(Standard Swapping)
- 전체 프로세스를 메인 메모리와 백업 저장소(backing store) 사이에 이동시킴
- **물리 메모리 초과(over-subscription)** 를 허용하여, 더 많은 프로세스를 동시에 수용 가능
- 그러나 **전체 프로세스를 이동하는 데 시간이 너무 많이 걸리므로** 현대 운영체제에서는 표준 스와핑은 일반적으로 사용되지 않음

### 현대 운영체제에서의 수정된 스와핑 (UNIX, Linux, Windows 등)
- 스와핑은 기본적으로 **비활성화(disabled)** 상태
- 메모리 사용량이 일정 임계치(threshold)를 초과할 경우에만 스와핑이 시작됨
- 메모리 수요가 임계치보다 낮아지면 다시 스와핑이 **비활성화**됨

> 결론적으로 현대 OS에서는 전체 프로세스 단위의 전통적 스와핑은 지양하고, 필요 시에만 제한적으로 수행하는 형태로 운영됨



## Context Switch Time and Swapping

### 표준 스와핑(Standard Swapping)
- 전체 프로세스를 메인 메모리와 백업 저장소(backing store) 사이에 이동시킴
- **물리 메모리 초과(over-subscription)** 를 허용하여, 더 많은 프로세스를 동시에 수용 가능
- 그러나 **전체 프로세스를 이동하는 데 시간이 너무 많이 걸리므로** 현대 운영체제에서는 표준 스와핑은 일반적으로 사용되지 않음

### 현대 운영체제에서의 수정된 스와핑 (UNIX, Linux, Windows 등)
- 스와핑은 기본적으로 **비활성화(disabled)** 상태
- 메모리 사용량이 일정 임계치(threshold)를 초과할 경우에만 스와핑이 시작됨
- 메모리 수요가 임계치보다 낮아지면 다시 스와핑이 **비활성화**됨

> 결론적으로 현대 OS에서는 전체 프로세스 단위의 전통적 스와핑은 지양하고, 필요 시에만 제한적으로 수행하는 형태로 운영됨

![[Pasted image 20250613153210.png]]


## Swapping on Mobile Systems

### 일반적으로 스와핑은 모바일 시스템에서 지원되지 않음
- 모바일 플랫폼은 **플래시 메모리 기반**이므로 다음과 같은 한계 존재:
  - 저장 공간이 작음
  - 쓰기 사이클 수가 제한적임
  - 플래시 메모리와 CPU 간 처리량이 낮음 (저속 I/O)

### 메모리가 부족할 경우 스와핑 대신 다른 방법 사용

#### iOS
- 앱에게 할당된 메모리를 **자발적으로 반환**하라고 요청함
  - 읽기 전용 데이터는 제거되고 필요시 플래시에서 다시 불러옴
  - 반환 실패 시 앱은 강제 종료될 수 있음

#### Android
- 여유 메모리가 부족할 경우 앱을 종료시킴
- 종료 전에 **앱 상태(application state)** 를 플래시에 기록하여 빠른 재시작 가능하게 함

> 참고: iOS와 Android 모두 **페이징(paging)** 은 지원함



## The Intel 32 and 64-bit Architectures

- 인텔은 업계를 선도하는 주요 칩 제조업체임
- **IA-32 아키텍처**: 펜티엄 계열 CPU는 32비트 기반으로, 이를 IA-32 아키텍처라고 부름
- **IA-64 아키텍처**: 현재의 인텔 CPU는 64비트 기반이며, 이를 IA-64 아키텍처라고 부름
- 다양한 파생 모델이 존재하므로 여기서는 핵심 개념들만 다룸


![[Pasted image 20250613153239.png]]


## IA-32 Segmentation

IA-32 아키텍처는 **세그멘테이션(segmentation)** 과 **세그멘테이션 + 페이징(segmentation with paging)** 둘 다 지원함

- 각 세그먼트는 최대 **4GB** 크기 가능
- 프로세스당 최대 **16K (16,384)** 개의 세그먼트 사용 가능
- 세그먼트는 **두 개의 파티션**으로 나뉨:
  - 첫 번째 파티션 (최대 8K 세그먼트): 프로세스 **전용**, `LDT(Local Descriptor Table)`에 저장됨
  - 두 번째 파티션 (최대 8K 세그먼트): 모든 프로세스 간 **공유**, `GDT(Global Descriptor Table)`에 저장됨


## IA-32 Segmentation (논리 → 선형 주소 변환)

- **CPU는 논리 주소(logical address)** 를 생성하며, 이는 `selector`와 `offset`으로 구성됨
- **Selector**는 세그멘테이션 유닛에 전달되어 **선형 주소(linear address)** 를 생성함

### Selector 비트 구성
- `s`: segment 번호 (13비트)
- `g`: GDT(0) 또는 LDT(1) 여부 (1비트)
- `p`: protection 관련 플래그 (2비트)

### 변환 흐름
- 논리 주소 → 세그먼트 디스크립터 → base 주소 + offset → 32비트 선형 주소

## IA-32 Paging (선형 → 물리 주소 변환)

- IA-32는 페이지 크기로 **4KB 또는 4MB** 지원
- 4KB 페이지의 경우 **2단계 페이징(two-level paging)** 사용

### 주소 비트 분할 (4KB 기준)
- `p1` (상위 10비트): 페이지 디렉터리 인덱스
- `p2` (중간 10비트): 페이지 테이블 인덱스
- `d`  (하위 12비트): 페이지 내 오프셋

### 4MB 페이지 지원
- `Page_Size` 플래그가 설정된 경우, 페이지 디렉터리에서 직접 4MB 페이지를 가리킴
- 이 경우 **내부 페이지 테이블을 우회**함

> 전체 흐름: 논리 주소 → 선형 주소 (세그멘테이션) → 물리 주소 (페이징)


## IA-32 Page Address Extensions (PAE)

### 배경
- 32비트 주소는 최대 **4GB** 메모리 공간만 접근 가능함
- 이를 확장하기 위해 **Page Address Extension (PAE)** 기술 도입
- PAE는 32비트 운영체제에서도 **64GB의 물리 메모리** 접근을 가능하게 함

### 주요 특징
- **3단계 페이지 테이블 구조** 사용
  - 기존의 2단계 (Page Directory → Page Table) 에서 → Page Directory Pointer Table(PDPT) 추가됨
- **상위 2비트**는 `Page Directory Pointer Table (PDPT)`을 가리킴
- 각 **디렉터리와 테이블 항목은 64비트 크기**로 확장됨
- 주소 공간이 **36비트**로 증가 → 총 **64GB** 메모리 공간 주소 가능

### 주소 변환 흐름
1. 논리 주소 상위 2비트 → `Page Directory Pointer Table`
2. 중간 9비트 → `Page Directory`
3. 다음 9비트 → `Page Table`
4. 하위 12비트 → 페이지 내부 offset

> PAE는 32비트 시스템에서도 더 큰 메모리 공간을 활용할 수 있게 해 주는 중요한 확장 기능임


## Intel x86-64 Architecture

### 개요
- 인텔의 최신 x86 아키텍처는 **64비트 주소 체계**를 사용
- 이론적으로는 **16엑사바이트(2⁶⁴ bytes)** 이상의 주소 공간을 가짐
- 하지만 실제로는 **48비트 가상 주소**만 구현됨

### 세부 사항
- 지원하는 페이지 크기: **4KB**, **2MB**, **1GB**
- 페이지 테이블 계층은 총 **4단계**로 구성됨
  - Page Map Level 4
  - Page Directory Pointer Table
  - Page Directory
  - Page Table

### PAE와의 연계
- PAE(Page Address Extension) 사용 시,
  - 가상 주소: **48비트**
  - 물리 주소: **52비트 (4096 TB)** 까지 확장 가능

> 64비트 아키텍처에서도 메모리 접근 효율성과 하드웨어 구현 현실을 고려하여 제한된 비트만 실제 사용함
