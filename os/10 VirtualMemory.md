## 📘Background (Virtual Memory)

- **명령어는 물리 메모리에 있어야 실행 가능함**
  - → 그렇다면 전체 프로그램을 메모리에 올려야 할까?

- **일부 코드는 실행 중 거의 사용되지 않음**
  - 예외 처리 코드
  - 필요 이상으로 큰 배열/리스트
  - 자주 호출되지 않는 서브루틴 등

- **대안**
  - 프로그램의 일부만 메모리에 올리고 실행하는 방식
  - → 가상 메모리 개념의 필요성 제시

- **프로그램을 부분적으로 메모리에 올려 실행할 수 있다면** 다음과 같은 이점이 있음:
  - 물리 메모리 크기에 의해 프로그램 실행이 제한되지 않음
  - 동시에 더 많은 프로그램을 실행 가능
  - 프로그램을 로드하거나 스왑하는 데 필요한 I/O 감소


## 📘 Virtual Memory

- **가상 메모리(Virtual Memory)**: 사용자 논리 메모리와 물리 메모리의 분리
- 장점:
  - 프로그램 일부만 메모리에 올려도 실행 가능
  - 논리 주소 공간이 물리 주소 공간보다 훨씬 클 수 있음
  - 여러 프로세스가 주소 공간을 공유 가능
  - 프로세스 생성 효율 향상 (예: Copy-on-Write)
  - 동시에 더 많은 프로그램 실행 가능
  - 프로그램 로드·스왑 시 I/O 비용 감소
  - ![[Pasted image 20250513141000.png]]

> ⬅ 그림 설명: 논리 메모리는 물리 메모리 및 보조 저장장치와 매핑되어 있음


## 📘 Virtual Address Space

- **가상 주소 공간(Virtual Address Space)**: 프로세스가 메모리에 저장되는 논리적 구조
- 특징:
  - 일반적으로 주소 0부터 시작하여 연속적인 주소로 구성
  - 실제 물리 메모리는 페이지 프레임 단위로 구성됨
  - MMU(Memory Management Unit)가 논리 주소를 물리 주소에 매핑
  - 프로그래머는 메모리 관리 부담을 덜 수 있음
  - 가상 주소 공간은 **희소(sparse)**할 수 있음
    - 예: 스택/힙이 확장되거나 동적 라이브러리 연결 시 중간 공간이 채워짐
![[Pasted image 20250513141303.png]]

> ⬅ 그림 설명: 코드, 데이터, 힙, 스택 영역으로 구성된 전형적인 가상 주소 공간 구조


## 📘Page Sharing

- 가상 메모리는 **두 개 이상의 프로세스가 파일과 메모리를 공유**할 수 있도록 함
- 공유 방식:
  - 시스템 라이브러리를 가상 주소 공간에 매핑하여 공유
  - 공유 메모리를 읽기/쓰기 가능한 페이지로 매핑하여 가상 주소 공간에 배치
  - `fork()` 호출 시 페이지를 공유하여 **프로세스 생성 속도 향상**


## 📘 Demand Paging

- **Demand Paging**: 페이지는 **실제로 필요할 때만 메모리에 적재**
  - 프로그램 실행 중 요구된 시점에 로딩됨
- 장점:
  - 스와핑 기반 페이징과 유사하지만 **불필요한 I/O 없음**
  - **적은 메모리 사용량**
  - **빠른 응답 시간**
  - **더 많은 사용자 수용 가능**
- 필요 조건:
  - 페이지가 **메모리에 있는지 디스크에 있는지 구분할 수 있는 하드웨어 지원** 필요
    - (→ valid-invalid 비트를 통한 페이지 상태 구분)
![[Pasted image 20250513142552.png]]
> ⬅ 그림 설명:
> - 논리 메모리에서 A~H 페이지가 존재
> - 페이지 테이블은 각 페이지가 **어느 프레임에 있고 유효한지** 나타냄
> - 유효하지 않은 페이지는 **백업 저장소(backing store)**에 있음


## 📘Page Table with Valid-Invalid Bit

- **유효/무효 비트(valid/invalid bit)**는 각 페이지가 물리 메모리에 존재하는지 여부를 나타냄

### 🟢 Valid
- 해당 페이지가 **물리 메모리에 존재**
- 접근 시 **정상적으로 실행됨**

### 🔴 Invalid
- 해당 페이지가:
  - 프로세스의 유효한 논리 주소 공간에 **속하지 않거나**
  - 아직 물리 메모리에 **로드되지 않음**
- 접근 시 **페이지 폴트(page fault)** 발생 → OS가 처리


## 📘 Handling Page-Fault

- **페이지 폴트(Page Fault)** 처리 절차:

1. 내부 테이블(예: 페이지 테이블)을 확인하여 **참조가 유효한 주소인지 검사**
2. 주소가 **무효(invalid)**이면 → **프로세스 종료**
3. 주소가 유효하지만 아직 메모리에 없으면 → **해당 페이지를 메모리에 적재**

### 📌 페이지 적재 과정:
- 빈 프레임 찾기
- 원하는 페이지를 디스크에서 읽어와 그 프레임에 적재
- 페이지 테이블 수정 (valid 비트 갱신 등)
- 해당 명령어를 다시 시작 (재시도)
![[Pasted image 20250513143623.png]]
> ⬅ 그림 설명:
> 1. 프로세스가 유효하지 않은 페이지에 접근 시도
> 2. 트랩 발생 → OS로 제어 이동
> 3. 백업 저장소에서 해당 페이지 검색
> 4. 물리 메모리에 로딩
> 5. 페이지 테이블 수정
> 6. 중단된 명령어 재실행


## 📘 Aspects of Demand Paging

### 🔹 극단적인 경우 (Extreme Case)
- 프로세스를 **아무 페이지도 없이 시작**
- OS가 첫 명령어 위치로 IP 설정 → 페이지 폴트 발생
- 나머지 페이지들도 **접근 시마다 로드됨**
- → 이를 **Pure Demand Paging**이라 부름

### 🔹 하나의 명령어가 여러 페이지에 접근할 수도 있음
- 예: 메모리에서 두 값을 더하고 다시 저장하는 명령어
- → 이 경우 **여러 번의 페이지 폴트 발생 가능**
- 다행히 **참조 지역성(locality of reference)** 덕분에 실제로는 폴트 수 감소

### 🔹 Demand Paging에 필요한 하드웨어 지원
- 유효/무효 비트를 포함한 **페이지 테이블**
- **보조 기억 장치** (예: 스왑 공간)
- **명령어 재시작 기능**: 페이지 폴트 후 명령어 재실행


## 📘 Free-Frame List

- 페이지 폴트 발생 시, OS는 해당 페이지를 **보조 저장 장치에서 주기억 장치로 가져와야 함**
- 이를 위해 대부분의 운영체제는 **free-frame list (빈 프레임 목록)**을 유지함
- **Zero-fill-on-demand**:
  - 프레임을 할당하기 전에 내용을 0으로 초기화
- 시스템 부팅 시, 모든 사용 가능한 메모리는 free-frame list에 등록됨


## 📘Performance of Demand Paging

- **효과적인 접근 시간(Effective Access Time, EAT)**: EAT = (1 - p) * ma + p * page_fault_time
- `ma`: 메모리 접근 시간 (10~200 ns)
- `p`: 페이지 폴트 확률
- page_fault_time: 
  - 인터럽트 처리 (1~100 μs)
  - 디스크에서 페이지 읽기 (~8 ms)
  - 프로세스 재시작 (1~100 μs)
- **페이지 폴트율은 매우 낮게 유지되어야 함**


## 📘 Demand Paging Optimizations

- **스왑 공간 I/O**는 파일 시스템 I/O보다 빠름
  - 이유: 더 큰 단위로 할당되고 관리 오버헤드 적음

- 프로그램 실행 방식:
  1. 전체 파일을 스왑 공간으로 복사 후 실행
  2. 처음엔 파일 시스템에서 demand paging, 이후는 스왑 공간에서 처리

- **모바일 시스템**:
  - 스왑 지원 안함
  - 파일 시스템에서 demand page 후, 읽기 전용 페이지 재사용


## 📘 Copy-on-Write

- **fork()** 호출 시 부모 프로세스의 페이지들을 **복사하지 않고 공유**함
- **Copy-on-Write (COW)**:
  - 초기에는 부모-자식이 같은 페이지를 **읽기 전용**으로 공유
  - 둘 중 하나가 해당 페이지에 **쓰기(write)** 시도 시, 그 순간 **실제 복사 발생**
  - → 프로세스 생성 속도 향상, 메모리 절약

- 추가 개념:
  - `vfork()`: 논리적으로 부모와 메모리를 공유하는 방법 (현재는 거의 사용 안 함)
  - 많은 OS는 COW나 힙/스택 확장을 위해 **Zero-fill-on-demand (ZFOD)** 프레임을 별도로 유지


## 📘 Two Major Problems in Demand Paging

- Demand Paging에서 주요 문제 두 가지:
  1. **Page Replacement Algorithm**
     - 페이지를 교체할 때 어떤 페이지를 제거할 것인가?
     - 초기 접근과 재접근 모두에서 **낮은 페이지 폴트율**이 이상적

  2. **Frame Allocation Algorithm**
     - 각 프로세스에 **얼마나 많은 프레임을 할당할 것인가?**
     - 어떤 프레임을 교체 대상으로 정할 것인가?

- 작은 개선만으로도 성능이 크게 향상될 수 있음


## 📘 Page Replacement 개요 

- 페이지 폴트 발생 시 **비어 있는 프레임이 없으면**, 사용 중이지 않은 프레임을 찾아 교체해야 함
- 페이지 교체 시, **dirty-bit(수정 비트)**를 사용하면 디스크 쓰기 비용 절감 가능


## 📘 Page Replacement 절차

1. 디스크에서 원하는 페이지의 위치 찾기  
2. 프레임 확보:
   - a. **빈 프레임**이 있다면 그대로 사용
   - b. 없으면 **페이지 교체 알고리즘**으로 희생(victim) 프레임 선택
   - c. 희생 프레임이 수정된 경우 디스크에 기록

3. 원하는 페이지를 확보한 프레임에 적재 → 페이지/프레임 테이블 갱신  
4. 폴트를 유발한 명령어 **재시작**

> 주의: 이 절차로 인해 **최대 2회의 페이지 전송** 발생 가능 → EAT 증가



## 📘 Page Faults vs. Number of Frames

- 일반적으로, **프레임 수가 많아질수록 페이지 폴트는 감소함**
- 하지만 모든 알고리즘에서 그런 것은 아님 → 예외 존재


## 📘 Page Replacement Algorithms 개요

- 다양한 페이지 교체 알고리즘 존재:
  - **FIFO (First-In, First-Out)**: 가장 오래된 페이지 제거
  - **Optimal (OPT)**: 미래에 가장 늦게 사용할 페이지 제거 (이론적 최적)
  - **LRU (Least Recently Used)**: 가장 오랫동안 사용하지 않은 페이지 제거
  - **LRU 근사 알고리즘**: 하드웨어 지원이 부족한 경우 사용
  - 기타 알고리즘 등

> ⬅ 이후 각 알고리즘별 예시와 비교 제시